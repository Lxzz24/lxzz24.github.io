# **访问数据库**


- [☘️ 使用 JDBC](#使用-JDBC)
- [☘️ 使用声明式事务](#使用声明式事务)
- [☘️ 使用 DAO](#使用-DAO)
- [☘️ 集成 Hibernate](#集成-Hibernate)
- [☘️ 集成 JPA](#集成-JPA)
- [☘️ 集成 MyBatis](#集成-MyBatis)
- [☘️ 设计 ORM](#设计-ORM)


数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。

我们在前面已经介绍了 Java 程序访问数据库的标准接口 JDBC，它的实现方式非常简洁，即：Java 标准库定义接口，各数据库厂商以 “驱动” 的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以 jar 包形式引入进来，同时自身仅使用 JDBC 接口，编译期并不需要特定厂商的驱动。

使用 JDBC 虽然简单，但代码比较繁琐。Spring 为了简化数据库访问，主要做了以下几点工作：

- 提供了简化的访问 JDBC 的模板类，不必手动释放资源；
- 提供了一个统一的 DAO 类以实现 Data Access Object 模式；
- 把 `SQLException` 封装为 `DataAccessException`，这个异常是一个 `RuntimeException`，并且让我们能区分 SQL 异常的原因，例如，`DuplicateKeyException` 表示违反了一个唯一约束；
- 能方便地集成 Hibernate、JPA 和 MyBatis 这些数据库访问框架。

本章我们将详细讲解在 Spring 中访问数据库的最佳实践。



# **使用 JDBC**

我们在前面介绍 [JDBC 编程](https://www.liaoxuefeng.com/wiki/1252599548343744/1255943820274272) 时已经讲过，Java 程序使用 JDBC 接口访问关系数据库的时候，需要以下几步：

- 创建全局 `DataSource` 实例，表示数据库连接池；
- 在需要读写数据库的方法内部，按如下步骤访问数据库：
    - 从全局 `DataSource` 实例获取 `Connection` 实例；
    - 通过 `Connection` 实例创建 `PreparedStatement` 实例；
    - 执行 SQL 语句，如果是查询，则通过 `ResultSet` 读取结果集，如果是修改，则获得 `int` 结果。

正确编写 JDBC 代码的关键是使用 `try ... finally` 释放资源，涉及到事务的代码需要正确提交或回滚事务。

在 Spring 使用 JDBC，首先我们通过 IoC 容器创建并管理一个 `DataSource` 实例，然后，Spring 提供了一个 `JdbcTemplate`，可以方便地让我们操作 JDBC，因此，通常情况下，我们会实例化一个 `JdbcTemplate`。顾名思义，这个类主要使用了 [Template 模式](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319636041762)。

编写示例代码或者测试代码时，我们强烈推荐使用 [HSQLDB](http://hsqldb.org/) 这个数据库，它是一个用 Java 编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个 jar 包，非常适合演示代码或者测试代码。

我们以实际工程为例，先创建 Maven 工程 `spring-data-jdbc`，然后引入以下依赖：

- org.springframework:spring-context:6.0.0
- org.springframework:spring-jdbc:6.0.0
- jakarta.annotation:jakarta.annotation-api:2.1.1
- com.zaxxer:HikariCP:5.0.1
- org.hsqldb:hsqldb:2.7.1

在 `AppConfig` 中，我们需要创建以下几个必须的 Bean：

```java
@Configuration
@ComponentScan
@PropertySource("jdbc.properties")
public class AppConfig {

    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

在上述配置中：

1. 通过 `@PropertySource("jdbc.properties")` 读取数据库配置文件；
2. 通过 `@Value("${jdbc.url}")` 注入配置文件的相关配置；
3. 创建一个 DataSource 实例，它的实际类型是 `HikariDataSource`，创建时需要用到注入的配置；
4. 创建一个 JdbcTemplate 实例，它需要注入 `DataSource`，这是通过方法参数完成注入的。

最后，针对 HSQLDB 写一个配置文件 `jdbc.properties`：

```conf
# 数据库文件名为 testdb:
jdbc.url=jdbc:hsqldb:file:testdb

# Hsqldb 默认的用户名是 sa，口令是空字符串:
jdbc.username=sa
jdbc.password=
```

可以通过 HSQLDB 自带的工具来初始化数据库表，这里我们写一个 Bean，在 Spring 容器启动时自动创建一个 `users` 表：

```java
@Component
public class DatabaseInitializer {
    @Autowired
    JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users (" //
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY," //
                + "email VARCHAR(100) NOT NULL," //
                + "password VARCHAR(100) NOT NULL," //
                + "name VARCHAR(100) NOT NULL," //
                + "UNIQUE (email))");
    }
}
```

现在，所有准备工作都已完毕。我们只需要在需要访问数据库的 Bean 中，注入 `JdbcTemplate` 即可：

```java
@Component
public class UserService {
    @Autowired
    JdbcTemplate jdbcTemplate;
    ...
}
```

## JdbcTemplate 用法

Spring 提供的 `JdbcTemplate` 采用 Template 模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的 `try...catch` 语句。

我们以具体的示例来说明 JdbcTemplate 的用法。

首先我们看 `T execute(ConnectionCallback<T> action)` 方法，它提供了 Jdbc 的 `Connection` 供我们使用：

```java
public User getUserById(long id) {
    // 注意传入的是 ConnectionCallback:
    return jdbcTemplate.execute((Connection conn) -> {
        // 可以直接使用 conn 实例，不要释放它，回调结束后 JdbcTemplate 自动释放:
        // 在内部手动创建的 PreparedStatement、ResultSet 必须用 try(...) 释放:
        try (var ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {
            ps.setObject(1, id);
            try (var rs = ps.executeQuery()) {
                if (rs.next()) {
                    return new User( // new User object:
                            rs.getLong("id"), // id
                            rs.getString("email"), // email
                            rs.getString("password"), // password
                            rs.getString("name")); // name
                }
                throw new RuntimeException("user not found by id.");
            }
        }
    });
}
```

也就是说，上述回调方法允许获取 Connection，然后做任何基于 Connection 的操作。

我们再看 `T execute(String sql, PreparedStatementCallback<T> action)` 的用法：

```java
public User getUserByName(String name) {
    // 需要传入 SQL 语句，以及 PreparedStatementCallback:
    return jdbcTemplate.execute("SELECT * FROM users WHERE name = ?", (PreparedStatement ps) -> {
        // PreparedStatement 实例已经由 JdbcTemplate 创建，并在回调后自动释放:
        ps.setObject(1, name);
        try (var rs = ps.executeQuery()) {
            if (rs.next()) {
                return new User( // new User object:
                        rs.getLong("id"), // id
                        rs.getString("email"), // email
                        rs.getString("password"), // password
                        rs.getString("name")); // name
            }
            throw new RuntimeException("user not found by id.");
        }
    });
}
```

最后，我们看 `T queryForObject(String sql, RowMapper<T> rowMapper, Object... args)` 方法：

```java
public User getUserByEmail(String email) {
    // 传入 SQL，参数和 RowMapper 实例:
    return jdbcTemplate.queryForObject("SELECT * FROM users WHERE email = ?",
            (ResultSet rs, int rowNum) -> {
                // 将 ResultSet 的当前行映射为一个 JavaBean:
                return new User( // new User object:
                        rs.getLong("id"), // id
                        rs.getString("email"), // email
                        rs.getString("password"), // password
                        rs.getString("name")); // name
            },
            email);
}
```

在 `queryForObject()` 方法中，传入 SQL 以及 SQL 参数后，`JdbcTemplate` 会自动创建 `PreparedStatement`，自动执行查询并返回 `ResultSet`，我们提供的 `RowMapper` 需要做的事情就是把 `ResultSet` 的当前行映射成一个 JavaBean 并返回。整个过程中，使用 `Connection`、`PreparedStatement` 和 `ResultSet` 都不需要我们手动管理。

`RowMapper` 不一定返回 JavaBean，实际上它可以返回任何 Java 对象。例如，使用 `SELECT COUNT(*)` 查询时，可以返回 `Long`：

```java
public long getUsers() {
    return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM users", (ResultSet rs, int rowNum) -> {
        // SELECT COUNT(*) 查询只有一列，取第一列数据:
        return rs.getLong(1);
    });
}
```

如果我们期望返回多行记录，而不是一行，可以用 `query()` 方法：

```java
public List<User> getUsers(int pageIndex) {
    int limit = 100;
    int offset = limit * (pageIndex - 1);
    return jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?",
            new BeanPropertyRowMapper<>(User.class),
            limit, offset);
}
```

上述 `query()` 方法传入的参数仍然是 SQL、SQL 参数以及 `RowMapper` 实例。这里我们直接使用 Spring 提供的 `BeanPropertyRowMapper`。如果数据库表的结构恰好和 JavaBean 的属性名称一致，那么 `BeanPropertyRowMapper` 就可以直接把一行记录按列名转换为 JavaBean。

如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用 `update()` 方法：

```java
public void updateUser(User user) {
    // 传入 SQL，SQL 参数，返回更新的行数:
    if (1 != jdbcTemplate.update("UPDATE users SET name = ? WHERE id = ?", user.getName(), user.getId())) {
        throw new RuntimeException("User not found by id");
    }
}
```

只有一种 `INSERT` 操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。`JdbcTemplate` 提供了一个 `KeyHolder` 来简化这一操作：

```java
public User register(String email, String password, String name) {
    // 创建一个 KeyHolder:
    KeyHolder holder = new GeneratedKeyHolder();
    if (1 != jdbcTemplate.update(
        // 参数 1:PreparedStatementCreator
        (conn) -> {
            // 创建 PreparedStatement 时，必须指定 RETURN_GENERATED_KEYS:
            var ps = conn.prepareStatement("INSERT INTO users(email, password, name) VALUES(?, ?, ?)",
                    Statement.RETURN_GENERATED_KEYS);
            ps.setObject(1, email);
            ps.setObject(2, password);
            ps.setObject(3, name);
            return ps;
        },
        // 参数 2:KeyHolder
        holder)
    ) {
        throw new RuntimeException("Insert failed.");
    }
    // 从 KeyHolder 中获取返回的自增值:
    return new User(holder.getKey().longValue(), email, password, name);
}
```

`JdbcTemplate` 还有许多重载方法，这里我们不一一介绍。需要强调的是，`JdbcTemplate` 只是对 JDBC 操作的一个简单封装，它的目的是尽量减少手动编写 `try(resource) {...}` 的代码，对于查询，主要通过 `RowMapper` 实现了 JDBC 结果集到 Java 对象的转换。

我们总结一下 `JdbcTemplate` 的用法，那就是：

- 针对简单查询，优选 `query()` 和 `queryForObject()`，因为只需提供 SQL 语句、参数和 `RowMapper`；
- 针对更新操作，优选 `update()`，因为只需提供 SQL 语句和参数；
- 任何复杂的操作，最终也可以通过 `execute(ConnectionCallback)` 实现，因为拿到 `Connection` 就可以做任何 JDBC 操作。

实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和 JavaBean 的属性一一对应，那么直接使用 `BeanPropertyRowMapper` 就很方便。如果表结构和 JavaBean 不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和 JavaBean 保持一致。

例如，表的列名是 `office_address`，而 JavaBean 属性是 `workAddress`，就需要指定别名，改写查询如下：

```sql
SELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?
```

## 练习


## 小结

Spring 提供了 `JdbcTemplate` 来简化 JDBC 操作；

使用 `JdbcTemplate` 时，根据需要优先选择高级方法；

任何 JDBC 操作都可以使用保底的 `execute(ConnectionCallback)` 方法。



# **使用声明式事务**


使用 Spring 操作 JDBC 虽然方便，但是我们在前面讨论 JDBC 的时候，讲到过 [JDBC 事务](https://www.liaoxuefeng.com/wiki/1252599548343744/1321748500840481)，如果要在 Spring 中操作事务，没必要手写 JDBC 事务，可以使用 Spring 提供的高级接口来操作事务。

Spring 提供了一个 `PlatformTransactionManager` 来表示事务管理器，所有的事务都由它负责管理。而事务由 `TransactionStatus` 表示。如果手写事务代码，使用 `try...catch` 如下：

```java
TransactionStatus tx = null;
try {
    // 开启事务:
    tx = txManager.getTransaction(new DefaultTransactionDefinition());
    // 相关 JDBC 操作:
    jdbcTemplate.update("...");
    jdbcTemplate.update("...");
    // 提交事务:
    txManager.commit(tx);
} catch (RuntimeException e) {
    // 回滚事务:
    txManager.rollback(tx);
    throw e;
}
```

Spring 为啥要抽象出 `PlatformTransactionManager` 和 `TransactionStatus`？原因是 JavaEE 除了提供 JDBC 事务外，它还支持分布式事务 JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。

Spring 为了同时支持 JDBC 和 JTA 两种事务模型，就抽象出 `PlatformTransactionManager`。因为我们的代码只需要 JDBC 事务，因此，在 `AppConfig` 中，需要再定义一个 `PlatformTransactionManager` 对应的 Bean，它的实际类型是 `DataSourceTransactionManager`：

```java
@Configuration
@ComponentScan
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

使用编程的方式使用 Spring 事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在 `AppConfig` 中追加一个上述定义的 `PlatformTransactionManager` 外，再加一个 `@EnableTransactionManagement` 就可以启用声明式事务：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement // 启用声明式
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
}
```

然后，对需要事务支持的方法，加一个 `@Transactional` 注解：

```java
@Component
public class UserService {
    // 此 public 方法自动具有事务支持:
    @Transactional
    public User register(String email, String password, String name) {
       ...
    }
}
```

或者更简单一点，直接在 Bean 的 `class` 处加上，表示所有 `public` 方法都具有事务支持：

```java
@Component
@Transactional
public class UserService {
    ...
}
```

Spring 对一个声明式事务的方法，如何开启事务支持？原理仍然是 AOP 代理，即通过自动创建 Bean 的 Proxy 实现：

```java
public class UserService$$EnhancerBySpringCGLIB extends UserService {
    UserService target = ...
    PlatformTransactionManager txManager = ...

    public User register(String email, String password, String name) {
        TransactionStatus tx = null;
        try {
            tx = txManager.getTransaction(new DefaultTransactionDefinition());
            target.register(email, password, name);
            txManager.commit(tx);
        } catch (RuntimeException e) {
            txManager.rollback(tx);
            throw e;
        }
    }
    ...
}
```

注意：声明了 `@EnableTransactionManagement` 后，不必额外添加 `@EnableAspectJAutoProxy`。

## 回滚事务

默认情况下，如果发生了 `RuntimeException`，Spring 的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出 `RuntimeException`，例如：

```java
@Transactional
public buyProducts(long productId, int num) {
    ...
    if (store < num) {
        // 库存不够，购买失败:
        throw new IllegalArgumentException("No enough products");
    }
    ...
}
```

如果要针对 Checked Exception 回滚事务，需要在 `@Transactional` 注解中写出来：

```java
@Transactional(rollbackFor = {RuntimeException.class, IOException.class})
public buyProducts(long productId, int num) throws IOException {
    ...
}
```

上述代码表示在抛出 `RuntimeException` 或 `IOException` 时，事务将回滚。

为了简化代码，我们强烈建议业务异常体系从 `RuntimeException` 派生，这样就不必声明任何特殊异常即可让 Spring 的声明式事务正常工作：

```java
public class BusinessException extends RuntimeException {
    ...
}

public class LoginException extends BusinessException {
    ...
}

public class PaymentException extends BusinessException {
    ...
}
```

## 事务边界

在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的 `register()` 方法：

```java
@Component
public class UserService {
    @Transactional
    public User register(String email, String password, String name) { // 事务开始
       ...
    } // 事务结束
}
```

它的事务边界就是 `register()` 方法开始和结束。

类似的，一个负责给用户增加积分的 `addBonus()` 方法：

```java
@Component
public class BonusService {
    @Transactional
    public void addBonus(long userId, int bonus) { // 事务开始
       ...
    } // 事务结束
}
```

它的事务边界就是 `addBonus()` 方法开始和结束。

在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得 100 积分，因此，实际代码如下：

```java
@Component
public class UserService {
    @Autowired
    BonusService bonusService;

    @Transactional
    public User register(String email, String password, String name) {
        // 插入用户记录:
        User user = jdbcTemplate.insert("...");
        // 增加 100 积分:
        bonusService.addBonus(user.id, 100);
    }
}
```

现在问题来了：调用方（比如 `RegisterController`）调用 `UserService.register()` 这个事务方法，它在内部又调用了 `BonusService.addBonus()` 这个事务方法，一共有几个事务？如果 `addBonus()` 抛出了异常需要回滚事务，`register()` 方法的事务是否也要回滚？

问题的复杂度是不是一下子提高了 10 倍？

## 事务传播

要解决上面的问题，我们首先要定义事务的传播模型。

假设用户注册的入口是 `RegisterController`，它本身没有事务，仅仅是调用 `UserService.register()` 这个事务方法：

```java
@Controller
public class RegisterController {
    @Autowired
    UserService userService;

    @PostMapping("/register")
    public ModelAndView doRegister(HttpServletRequest req) {
        String email = req.getParameter("email");
        String password = req.getParameter("password");
        String name = req.getParameter("name");
        User user = userService.register(email, password, name);
        return ...
    }
}
```

因此，`UserService.register()` 这个事务方法的起始和结束，就是事务的范围。

我们需要关心的问题是，在 `UserService.register()` 这个事务方法内，调用 `BonusService.addBonus()`，我们期待的事务行为是什么：

```java
@Transactional
public User register(String email, String password, String name) {
    // 事务已开启:
    User user = jdbcTemplate.insert("...");
    // ???:
    bonusService.addBonus(user.id, 100);
} // 事务结束
```

对于大多数业务来说，我们期待 `BonusService.addBonus()` 的调用，和 `UserService.register()` 应当融合在一起，它的行为应该如下：

`UserService.register()` 已经开启了一个事务，那么在内部调用 `BonusService.addBonus()` 时，`BonusService.addBonus()` 方法就没必要再开启一个新事务，直接加入到 `BonusService.register()` 的事务里就好了。

其实就相当于：

1. `UserService.register()` 先执行了一条 INSERT 语句：`INSERT INTO users ...`
2. `BonusService.addBonus()` 再执行一条 INSERT 语句：`INSERT INTO bonus ...`

因此，Spring 的声明式事务为事务传播定义了几个级别，默认传播级别就是 REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。

我们观察 `UserService.register()` 方法，它在 `RegisterController` 中执行，因为 `RegisterController` 没有事务，因此，`UserService.register()` 方法会自动创建一个新事务。

在 `UserService.register()` 方法内部，调用 `BonusService.addBonus()` 方法时，因为 `BonusService.addBonus()` 检测到当前已经有事务了，因此，它会加入到当前事务中执行。

因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是 `UserService.register()` 方法。

有的童鞋会问：把 `BonusService.addBonus()` 方法的 `@Transactional` 去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？

去掉 `BonusService.addBonus()` 方法的 `@Transactional`，会引来另一个问题，即其他地方如果调用 `BonusService.addBonus()` 方法，那就没法保证事务了。例如，规定用户登录时积分 + 5：

```java
@Controller
public class LoginController {
    @Autowired
    BonusService bonusService;

    @PostMapping("/login")
    public ModelAndView doLogin(HttpServletRequest req) {
        User user = ...
        bonusService.addBonus(user.id, 5);
    }
}
```

可见，`BonusService.addBonus()` 方法必须要有 `@Transactional`，否则，登录后积分就无法添加了。

默认的事务传播级别是 `REQUIRED`，它满足绝大部分的需求。还有一些其他的传播级别：

`SUPPORTS`：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为 SELECT 语句既可以在事务内执行，也可以不需要事务；

`MANDATORY`：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；

`REQUIRES_NEW`：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；

`NOT_SUPPORTED`：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；

`NEVER`：和 `NOT_SUPPORTED` 相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；

`NESTED`：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。

上面这么多种事务的传播级别，其实默认的 `REQUIRED` 已经满足绝大部分需求，`SUPPORTS` 和 `REQUIRES_NEW` 在少数情况下会用到，其他基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。

定义事务的传播级别也是写在 `@Transactional` 注解里的：

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public Product createProduct() {
    ...
}
```

现在只剩最后一个问题了：Spring 是如何传播事务的？

我们 [在 JDBC 中使用事务](/1-Java/17_JDBC编程/4.md) 的时候，是这么个写法：

```java
Connection conn = openConnection();
try {
    // 关闭自动提交:
    conn.setAutoCommit(false);
    // 执行多条 SQL 语句:
    insert(); update(); delete();
    // 提交事务:
    conn.commit();
} catch (SQLException e) {
    // 回滚事务:
    conn.rollback();
} finally {
    conn.setAutoCommit(true);
    conn.close();
}
```

Spring 使用声明式事务，最终也是通过执行 JDBC 事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？

答案是 [使用 ThreadLocal](/1-Java/13_多线程/22.md)。Spring 总是把 JDBC 相关的 `Connection` 和 `TransactionStatus` 实例绑定到 `ThreadLocal`。如果一个事务方法从 `ThreadLocal` 未取到事务，那么它会打开一个新的 JDBC 连接，同时开启一个新的事务，否则，它就直接使用从 `ThreadLocal` 获取的 JDBC 连接以及 `TransactionStatus`。

因此，事务能正确传播的前提是，方法调用是在一个线程内才行。如果像下面这样写：

```java
@Transactional
public User register(String email, String password, String name) { // BEGIN TX-A
    User user = jdbcTemplate.insert("...");
    new Thread(() -> {
        // BEGIN TX-B:
        bonusService.addBonus(user.id, 100);
        // END TX-B
    }).start();
} // END TX-A
```

在另一个线程中调用 `BonusService.addBonus()`，它根本获取不到当前事务，因此，`UserService.register()` 和 `BonusService.addBonus()` 两个方法，将分别开启两个完全独立的事务。

换句话说，事务只能在当前线程传播，无法跨线程传播。

那如果我们想实现跨线程传播事务呢？原理很简单，就是要想办法把当前线程绑定到 `ThreadLocal` 的 `Connection` 和 `TransactionStatus` 实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。

## 练习


## 小结

Spring 提供的声明式事务极大地方便了在数据库中使用事务，正确使用声明式事务的关键在于确定好事务边界，理解事务传播级别。



# **使用 DAO**


在传统的多层应用程序中，通常是 Web 层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用 `JdbcTemplate` 实现对数据库的操作。

编写数据访问层的时候，可以使用 DAO 模式。DAO 即 Data Access Object 的缩写，它没有什么神秘之处，实现起来基本如下：

```java
public class UserDao {

    @Autowired
    JdbcTemplate jdbcTemplate;

    User getById(long id) {
        ...
    }

    List<User> getUsers(int page) {
        ...
    }

    User createUser(User user) {
        ...
    }

    User updateUser(User user) {
        ...
    }

    void deleteUser(User user) {
        ...
    }
}
```

Spring 提供了一个 `JdbcDaoSupport` 类，用于简化 DAO 的实现。这个 `JdbcDaoSupport` 没什么复杂的，核心代码就是持有一个 `JdbcTemplate`：

```java
public abstract class JdbcDaoSupport extends DaoSupport {

    private JdbcTemplate jdbcTemplate;

    public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        initTemplateConfig();
    }

    public final JdbcTemplate getJdbcTemplate() {
        return this.jdbcTemplate;
    }

    ...
}
```

它的意图是子类直接从 `JdbcDaoSupport` 继承后，可以随时调用 `getJdbcTemplate()` 获得 `JdbcTemplate` 的实例。那么问题来了：因为 `JdbcDaoSupport` 的 `jdbcTemplate` 字段没有标记 `@Autowired`，所以，子类想要注入 `JdbcTemplate`，还得自己想个办法：

```java
@Component
@Transactional
public class UserDao extends JdbcDaoSupport {
    @Autowired
    JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }
}
```

有的童鞋可能看出来了：既然 `UserDao` 都已经注入了 `JdbcTemplate`，那再把它放到父类里，通过 `getJdbcTemplate()` 访问岂不是多此一举？

如果使用传统的 XML 配置，并不需要编写 `@Autowired JdbcTemplate jdbcTemplate`，但是考虑到现在基本上是使用注解的方式，我们可以编写一个 `AbstractDao`，专门负责注入 `JdbcTemplate`：

```java
public abstract class AbstractDao extends JdbcDaoSupport {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }
}
```

这样，子类的代码就非常干净，可以直接调用 `getJdbcTemplate()`：

```java
@Component
@Transactional
public class UserDao extends AbstractDao {
    public User getById(long id) {
        return getJdbcTemplate().queryForObject(
                "SELECT * FROM users WHERE id = ?",
                new BeanPropertyRowMapper<>(User.class),
                id
        );
    }
    ...
}
```

倘若肯再多写一点样板代码，就可以把 `AbstractDao` 改成泛型，并实现 `getById()`，`getAll()`，`deleteById()` 这样的通用方法：

```java
public abstract class AbstractDao<T> extends JdbcDaoSupport {
    private String table;
    private Class<T> entityClass;
    private RowMapper<T> rowMapper;

    public AbstractDao() {
        // 获取当前类型的泛型类型:
        this.entityClass = getParameterizedType();
        this.table = this.entityClass.getSimpleName().toLowerCase() + "s";
        this.rowMapper = new BeanPropertyRowMapper<>(entityClass);
    }

    public T getById(long id) {
        return getJdbcTemplate().queryForObject("SELECT * FROM" + table + "WHERE id = ?", this.rowMapper, id);
    }

    public List<T> getAll(int pageIndex) {
        int limit = 100;
        int offset = limit * (pageIndex - 1);
        return getJdbcTemplate().query("SELECT * FROM" + table + "LIMIT ? OFFSET ?",
                new Object[] { limit, offset},
                this.rowMapper);
    }

    public void deleteById(long id) {
        getJdbcTemplate().update("DELETE FROM" + table + "WHERE id = ?", id);
    }
    ...
}
```

这样，每个子类就自动获得了这些通用方法：

```java
@Component
@Transactional
public class UserDao extends AbstractDao<User> {
    // 已经有了:
    // User getById(long)
    // List<User> getAll(int)
    // void deleteById(long)
}

@Component
@Transactional
public class BookDao extends AbstractDao<Book> {
    // 已经有了:
    // Book getById(long)
    // List<Book> getAll(int)
    // void deleteById(long)
}
```

可见，DAO 模式就是一个简单的数据访问模式，是否使用 DAO，根据实际情况决定，因为很多时候，直接在 Service 层操作数据库也是完全没有问题的。

## 练习


## 小结

Spring 提供了 `JdbcDaoSupport` 来便于我们实现 DAO 模式；

可以基于泛型实现更通用、更简洁的 DAO 模式。



# **集成 Hibernate**


使用 `JdbcTemplate` 的时候，我们用得最多的方法就是 `List<T> query(String, RowMapper, Object...)`。这个 `RowMapper` 的作用就是把 `ResultSet` 的一行记录映射为 Java Bean。

这种把关系数据库的表记录映射为 Java 对象的过程就是 ORM：Object-Relational Mapping。ORM 既可以把记录转换成 Java 对象，也可以把 Java 对象转换为行记录。

使用 `JdbcTemplate` 配合 `RowMapper` 可以看作是最原始的 ORM。如果要实现更自动化的 ORM，可以选择成熟的 ORM 框架，例如 [Hibernate](https://hibernate.org/)。

我们来看看如何在 Spring 中集成 Hibernate。

Hibernate 作为 ORM 框架，它可以替代 `JdbcTemplate`，但 Hibernate 仍然需要 JDBC 驱动，所以，我们需要引入 JDBC 驱动、连接池，以及 Hibernate 本身。在 Maven 中，我们加入以下依赖项：

- org.springframework:spring-context:6.0.0
- org.springframework:spring-orm:6.0.0
- jakarta.annotation:jakarta.annotation-api:2.1.1
- jakarta.persistence:jakarta.persistence-api:3.1.0
- org.hibernate:hibernate-core:6.1.4.Final
- com.zaxxer:HikariCP:5.0.1
- org.hsqldb:hsqldb:2.7.1

在 `AppConfig` 中，我们仍然需要创建 `DataSource`、引入 JDBC 配置文件，以及启用声明式事务：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() {
        ...
    }
}
```

为了启用 Hibernate，我们需要创建一个 `LocalSessionFactoryBean`：

```java
public class AppConfig {
    @Bean
    LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) {
        var props = new Properties();
        props.setProperty("hibernate.hbm2ddl.auto", "update"); // 生产环境不要使用
        props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
        props.setProperty("hibernate.show_sql", "true");
        var sessionFactoryBean = new LocalSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        // 扫描指定的 package 获取所有 entity class:
        sessionFactoryBean.setPackagesToScan("com.itranswarp.learnjava.entity");
        sessionFactoryBean.setHibernateProperties(props);
        return sessionFactoryBean;
    }
}
```

注意我们在 [定制 Bean](/1-Java/21_Spring开发/1.md#定制-Bean) 中讲到过 `FactoryBean`，`LocalSessionFactoryBean` 是一个 `FactoryBean`，它会再自动创建一个 `SessionFactory`，在 Hibernate 中，`Session` 是封装了一个 JDBC `Connection` 的实例，而 `SessionFactory` 是封装了 JDBC `DataSource` 的实例，即 `SessionFactory` 持有连接池，每次需要操作数据库的时候，`SessionFactory` 创建一个新的 `Session`，相当于从连接池获取到一个新的 `Connection`。`SessionFactory` 就是 Hibernate 提供的最核心的一个对象，但 `LocalSessionFactoryBean` 是 Spring 提供的为了让我们方便创建 `SessionFactory` 的类。

注意到上面创建 `LocalSessionFactoryBean` 的代码，首先用 `Properties` 持有 Hibernate 初始化 `SessionFactory` 时用到的所有设置，常用的设置请参考 [Hibernate 文档](https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations)，这里我们只定义了 3 个设置：

- `hibernate.hbm2ddl.auto=update`：表示自动创建数据库的表结构，注意不要在生产环境中启用；
- `hibernate.dialect=org.hibernate.dialect.HSQLDialect`：指示 Hibernate 使用的数据库是 HSQLDB。Hibernate 使用一种 HQL 的查询语句，它和 SQL 类似，但真正在 “翻译” 成 SQL 时，会根据设定的数据库 “方言” 来生成针对数据库优化的 SQL；
- `hibernate.show_sql=true`：让 Hibernate 打印执行的 SQL，这对于调试非常有用，我们可以方便地看到 Hibernate 生成的 SQL 语句是否符合我们的预期。

除了设置 `DataSource` 和 `Properties` 之外，注意到 `setPackagesToScan()` 我们传入了一个 `package` 名称，它指示 Hibernate 扫描这个包下面的所有 Java 类，自动找出能映射为数据库表记录的 JavaBean。后面我们会仔细讨论如何编写符合 Hibernate 要求的 JavaBean。

紧接着，我们还需要创建 `HibernateTransactionManager`：

```java
public class AppConfig {
    @Bean
    PlatformTransactionManager createTxManager(@Autowired SessionFactory sessionFactory) {
        return new HibernateTransactionManager(sessionFactory);
    }
}
```

`HibernateTransactionManager` 是配合 Hibernate 使用声明式事务所必须的。到此为止，所有的配置都定义完毕，我们来看看如何将数据库表结构映射为 Java 对象。

考察如下的数据库表：

```sql
CREATE TABLE user
    id BIGINT NOT NULL AUTO_INCREMENT,
    email VARCHAR(100) NOT NULL,
    password VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    createdAt BIGINT NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `email` (`email`)
;
```

其中，`id` 是自增主键，`email`、`password`、`name` 是 `VARCHAR` 类型，`email` 带唯一索引以确保唯一性，`createdAt` 存储整型类型的时间戳。用 JavaBean 表示如下：

```java
public class User {
    private Long id;
    private String email;
    private String password;
    private String name;
    private Long createdAt;

    // getters and setters
    ...
}
```

这种映射关系十分易懂，但我们需要添加一些注解来告诉 Hibernate 如何把 `User` 类映射到表记录：

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ...}

    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ...}

    @Column(nullable = false, length = 100)
    public String getPassword() { ...}

    @Column(nullable = false, length = 100)
    public String getName() { ...}

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ...}
}
```

如果一个 JavaBean 被用于映射，我们就标记一个 `@Entity`。默认情况下，映射的表名是 `user`，如果实际的表名不同，例如实际表名是 `users`，可以追加一个 `@Table(name="users")` 表示：

```java
@Entity
@Table(name="users")
public class User {
    ...
}
```

每个属性到数据库列的映射用 `@Column()` 标识，`nullable` 指示列是否允许为 `NULL`，`updatable` 指示该列是否允许被用在 `UPDATE` 语句，`length` 指示 `String` 类型的列的长度（如果没有指定，默认是 `255`）。

对于主键，还需要用 `@Id` 标识，自增主键再追加一个 `@GeneratedValue`，以便 Hibernate 能读取到自增主键的值。

细心的童鞋可能还注意到，主键 `id` 定义的类型不是 `long`，而是 `Long`。这是因为 Hibernate 如果检测到主键为 `null`，就不会在 `INSERT` 语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate 认为我们的程序指定了主键的值，会在 `INSERT` 语句中直接列出。`long` 型字段总是具有默认值 `0`，因此，每次插入的主键值总是 0，导致除第一次外后续插入都将失败。

`createdAt` 虽然是整型，但我们并没有使用 `long`，而是 `Long`，这是因为使用基本类型会导致 findByExample 查询会添加意外的条件，这里只需牢记，作为映射使用的 JavaBean，所有属性都使用包装类型而不是基本类型。

> [!WARNNING]
> 使用 Hibernate 时，不要使用基本类型的属性，总是使用包装类型，如 Long 或 Integer。

类似的，我们再定义一个 `Book` 类：

```java
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ...}

    @Column(nullable = false, length = 100)
    public String getTitle() { ...}

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ...}
}
```

如果仔细观察 `User` 和 `Book`，会发现它们定义的 `id`、`createdAt` 属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常我们会统一使用一种主键生成机制，并添加 `createdAt` 表示创建时间，`updatedAt` 表示修改时间等通用字段。

不必在 `User` 和 `Book` 中重复定义这些通用字段，我们可以把它们提到一个抽象类中：

```java
@MappedSuperclass
public abstract class AbstractEntity {

    private Long id;
    private Long createdAt;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ...}

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ...}

    @Transient
    public ZonedDateTime getCreatedDateTime() {
        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());
    }

    @PrePersist
    public void preInsert() {
        setCreatedAt(System.currentTimeMillis());
    }
}
```

对于 `AbstractEntity` 来说，我们要标注一个 `@MappedSuperclass` 表示它用于继承。此外，注意到我们定义了一个 `@Transient` 方法，它返回一个 “虚拟” 的属性。因为 `getCreatedDateTime()` 是计算得出的属性，而不是从数据库表读出的值，因此必须要标注 `@Transient`，否则 Hibernate 会尝试从数据库读取名为 `createdDateTime` 这个不存在的字段从而出错。

再注意到 `@PrePersist` 标识的方法，它表示在我们将一个 JavaBean 持久化到数据库之前（即执行 INSERT 语句），Hibernate 会先执行该方法，这样我们就可以自动设置好 `createdAt` 属性。

有了 `AbstractEntity`，我们就可以大幅简化 `User` 和 `Book`：

```java
@Entity
public class User extends AbstractEntity {

    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ...}

    @Column(nullable = false, length = 100)
    public String getPassword() { ...}

    @Column(nullable = false, length = 100)
    public String getName() { ...}
}
```

注意到使用的所有注解均来自 `jakarta.persistence`，它是 JPA 规范的一部分。这里我们只介绍使用注解的方式配置 Hibernate 映射关系，不再介绍传统的比较繁琐的 XML 配置。通过 Spring 集成 Hibernate 时，也不再需要 `hibernate.cfg.xml` 配置文件，用一句话总结：

 使用 Spring 集成 Hibernate，配合 JPA 注解，无需任何额外的 XML 配置。

类似 `User`、`Book` 这样的用于 ORM 的 Java Bean，我们通常称之为 Entity Bean。

最后，我们来看看如果对 `user` 表进行增删改查。因为使用了 Hibernate，因此，我们要做的，实际上是对 `User` 这个 JavaBean 进行 “增删改查”。我们编写一个 `UserService`，注入 `SessionFactory`：

```java
@Component
@Transactional
public class UserService {
    @Autowired
    SessionFactory sessionFactory;
}
```

## Insert 操作

要持久化一个 `User` 实例，我们只需调用 `persist()` 方法。以 `register()` 方法为例，代码如下：

```java
public User register(String email, String password, String name) {
    // 创建一个 User 对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);
    // 不要设置 id，因为使用了自增主键
    // 保存到数据库:
    sessionFactory.getCurrentSession().persist(user);
    // 现在已经自动获得了 id:
    System.out.println(user.getId());
    return user;
}
```

## Delete 操作

删除一个 `User` 相当于从表中删除对应的记录。注意 Hibernate 总是用 `id` 来删除记录，因此，要正确设置 `User` 的 `id` 属性才能正常删除记录：

```java
public boolean deleteUser(Long id) {
    User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
    if (user != null) {
        sessionFactory.getCurrentSession().remove(user);
        return true;
    }
    return false;
}
```

通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。注意到当记录不存在时，`load()` 返回 `null`。

## Update 操作

更新记录相当于先更新 `User` 的指定属性，然后调用 `merge()` 方法：

```java
public void updateUser(Long id, String name) {
    User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
    user.setName(name);
    sessionFactory.getCurrentSession().merge(user);
}
```

前面我们在定义 `User` 时，对有的属性标注了 `@Column(updatable=false)`。Hibernate 在更新记录时，它只会把 `@Column(updatable=true)` 的属性加入到 `UPDATE` 语句中，这样可以提供一层额外的安全性，即如果不小心修改了 `User` 的 `email`、`createdAt` 等属性，执行 `update()` 时并不会更新对应的数据库列。但也必须牢记：这个功能是 Hibernate 提供的，如果绕过 Hibernate 直接通过 JDBC 执行 `UPDATE` 语句仍然可以更新数据库的任意列的值。

最后，我们编写的大部分方法都是各种各样的查询。根据 `id` 查询我们可以直接调用 `load()`，如果要使用条件查询，例如，假设我们想执行以下查询：

```sql
SELECT * FROM user WHERE email = ? AND password = ?
```

我们来看看可以使用什么查询。

## 使用 HQL 查询

一种常用的查询是直接编写 Hibernate 内置的 HQL 查询：

```java
List<User> list = sessionFactory.getCurrentSession()
        .createQuery("from User u where u.email = ?1 and u.password = ?2", User.class)
        .setParameter(1, email).setParameter(2, password)
        .list();
```

和 SQL 相比，HQL 使用类名和属性名，由 Hibernate 自动转换为实际的表名和列名。详细的 HQL 语法可以参考 [Hibernate 文档](https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#query-language)。

除了可以直接传入 HQL 字符串外，Hibernate 还可以使用一种 `NamedQuery`，它给查询起个名字，然后保存在注解中。使用 `NamedQuery` 时，我们要先在 `User` 类标注：

```java
@NamedQueries(
    @NamedQuery(
        // 查询名称:
        name = "login",
        // 查询语句:
        query = "SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd"
    )
)
@Entity
public class User extends AbstractEntity {
    ...
}
```

注意到引入的 `NamedQuery` 是 `jakarta.persistence.NamedQuery`，它和直接传入 HQL 有点不同的是，占位符使用 `:e` 和 `:pwd`。

使用 `NamedQuery` 只需要引入查询名和参数：

```java
public User login(String email, String password) {
    List<User> list = sessionFactory.getCurrentSession()
        .createNamedQuery("login", User.class) // 创建 NamedQuery
        .setParameter("e", email) // 绑定 e 参数
        .setParameter("pwd", password) // 绑定 pwd 参数
        .list();
    return list.isEmpty() ? null : list.get(0);
}
```

直接写 HQL 和使用 `NamedQuery` 各有优劣。前者可以在代码中直观地看到查询语句，后者可以在 `User` 类统一管理所有相关查询。

## 练习


## 小结

在 Spring 中集成 Hibernate 需要配置的 Bean 如下：

- DataSource；
- LocalSessionFactory；
- HibernateTransactionManager。

推荐使用 Annotation 配置所有的 Entity Bean。



# **集成 JPA**


上一节我们讲了在 Spring 中集成 Hibernate。Hibernate 是第一个被广泛使用的 ORM 框架，但是很多小伙伴还听说过 JPA：Java Persistence API，这又是啥？

在讨论 JPA 之前，我们要注意到 JavaEE 早在 1999 年就发布了，并且有 Servlet、JMS 等诸多标准。和其他平台不同，Java 世界早期非常热衷于标准先行，各家跟进：大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想 JDBC）。

JPA 就是 JavaEE 的一个 ORM 标准，它的实现其实和 Hibernate 没啥本质区别，但是用户如果使用 JPA，那么引用的就是 `jakarta.persistence` 这个 “标准” 包，而不是 `org.hibernate` 这样的第三方包。因为 JPA 只是接口，所以，还需要选择一个实现产品，跟 JDBC 接口和 MySQL 驱动一个道理。

我们使用 JPA 时也完全可以选择 Hibernate 作为底层实现，但也可以选择其它的 JPA 提供方，比如 [EclipseLink](https://www.eclipse.org/eclipselink/)。Spring 内置了 JPA 的集成，并支持选择 Hibernate 或 EclipseLink 作为实现。这里我们仍然以主流的 Hibernate 作为 JPA 实现为例子，演示 JPA 的基本用法。

和使用 Hibernate 一样，我们只需要引入如下依赖：

- org.springframework:spring-context:6.0.0
- org.springframework:spring-orm:6.0.0
- jakarta.annotation:jakarta.annotation-api:2.1.1
- jakarta.persistence:jakarta.persistence-api:3.1.0
- org.hibernate:hibernate-core:6.1.4.Final
- com.zaxxer:HikariCP:5.0.1
- org.hsqldb:hsqldb:2.7.1

实际上我们这里引入的依赖和上一节集成 Hibernate 引入的依赖完全一样，因为 Hibernate 既提供了它自己的接口，也提供了 JPA 接口，我们用 JPA 接口就相当于通过 JPA 操作 Hibernate。

然后，在 `AppConfig` 中启用声明式事务管理，创建 `DataSource`：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() { ...}
}
```

使用 Hibernate 时，我们需要创建一个 `LocalSessionFactoryBean`，并让它再自动创建一个 `SessionFactory`。使用 JPA 也是类似的，我们也创建一个 `LocalContainerEntityManagerFactoryBean`，并让它再自动创建一个 `EntityManagerFactory`：

```java
@Bean
public LocalContainerEntityManagerFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) {
    var emFactory = new LocalContainerEntityManagerFactoryBean();
    // 注入 DataSource:
    emFactory.setDataSource(dataSource);
    // 扫描指定的 package 获取所有 entity class:
    emFactory.setPackagesToScan(AbstractEntity.class.getPackageName());
    // 使用 Hibernate 作为 JPA 实现:
    emFactory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
    // 其他配置项:
    var props = new Properties();
    props.setProperty("hibernate.hbm2ddl.auto", "update"); // 生产环境不要使用
    props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
    props.setProperty("hibernate.show_sql", "true");
    emFactory.setJpaProperties(props);
    return emFactory;
}
```

观察上述代码，除了需要注入 `DataSource` 和设定自动扫描的 `package` 外，还需要指定 JPA 的提供商，这里使用 Spring 提供的一个 `HibernateJpaVendorAdapter`，最后，针对 Hibernate 自己需要的配置，以 `Properties` 的形式注入。

最后，我们还需要实例化一个 `JpaTransactionManager`，以实现声明式事务：

```java
@Bean
PlatformTransactionManager createTxManager(@Autowired EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
}
```

这样，我们就完成了 JPA 的全部初始化工作。有些童鞋可能从网上搜索得知 JPA 需要 `persistence.xml` 配置文件，以及复杂的 `orm.xml` 文件。这里我们负责地告诉大家，使用 Spring+Hibernate 作为 JPA 实现，无需任何配置文件。

所有 Entity Bean 的配置和上一节完全相同，全部采用 Annotation 标注。我们现在只需关心具体的业务类如何通过 JPA 接口操作数据库。

还是以 `UserService` 为例，除了标注 `@Component` 和 `@Transactional` 外，我们需要注入一个 `EntityManager`，但是不要使用 `Autowired`，而是 `@PersistenceContext`：

```java
@Component
@Transactional
public class UserService {
    @PersistenceContext
    EntityManager em;
}
```

我们回顾一下 JDBC、Hibernate 和 JPA 提供的接口，实际上，它们的关系如下：

| JDBC       | Hibernate      | JPA                  |
| :--------- | :------------- | :------------------- |
| DataSource | SessionFactory | EntityManagerFactory |
| Connection | Session        | EntityManager        |

`SessionFactory` 和 `EntityManagerFactory` 相当于 `DataSource`，`Session` 和 `EntityManager` 相当于 `Connection`。每次需要访问数据库的时候，需要获取新的 `Session` 和 `EntityManager`，用完后再关闭。

但是，注意到 `UserService` 注入的不是 `EntityManagerFactory`，而是 `EntityManager`，并且标注了 `@PersistenceContext`。难道使用 JPA 可以允许多线程操作同一个 `EntityManager`？

实际上这里注入的并不是真正的 `EntityManager`，而是一个 `EntityManager` 的代理类，相当于：

```java
public class EntityManagerProxy implements EntityManager {
    private EntityManagerFactory emf;
}
```

Spring 遇到标注了 `@PersistenceContext` 的 `EntityManager` 会自动注入代理，该代理会在必要的时候自动打开 `EntityManager`。换句话说，多线程引用的 `EntityManager` 虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的 `EntityManager` 实例。

简单总结一下，标注了 `@PersistenceContext` 的 `EntityManager` 可以被多线程安全地共享。

因此，在 `UserService` 的每个业务方法里，直接使用 `EntityManager` 就很方便。以主键查询为例：

```java
public User getUserById(long id) {
    User user = this.em.find(User.class, id);
    if (user == null) {
        throw new RuntimeException("User not found by id:" + id);
    }
    return user;
}
```

与 HQL 查询类似，JPA 使用 JPQL 查询，它的语法和 HQL 基本差不多：

```java
public User fetchUserByEmail(String email) {
    // JPQL 查询:
    TypedQuery<User> query = em.createQuery("SELECT u FROM User u WHERE u.email = :e", User.class);
    query.setParameter("e", email);
    List<User> list = query.getResultList();
    if (list.isEmpty()) {
        return null;
    }
    return list.get(0);
}
```

同样的，JPA 也支持 `NamedQuery`，即先给查询起个名字，再按名字创建查询：

```java
public User login(String email, String password) {
    TypedQuery<User> query = em.createNamedQuery("login", User.class);
    query.setParameter("e", email);
    query.setParameter("pwd", password);
    List<User> list = query.getResultList();
    return list.isEmpty() ? null : list.get(0);
}
```

`NamedQuery` 通过注解标注在 `User` 类上，它的定义和上一节的 `User` 类一样：

```java
@NamedQueries(
    @NamedQuery(
        name = "login",
        query = "SELECT u FROM User u WHERE u.email=:e AND u.password=:pwd"
    )
)
@Entity
public class User {
    ...
}
```

对数据库进行增删改的操作，可以分别使用 `persist()`、`remove()` 和 `merge()` 方法，参数均为 Entity Bean 本身，使用非常简单，这里不再多述。

## 练习


## 小结

在 Spring 中集成 JPA 要选择一个实现，可以选择 Hibernate 或 EclipseLink；

使用 JPA 与 Hibernate 类似，但注入的核心资源是带有 `@PersistenceContext` 注解的 `EntityManager` 代理类。



# **集成 MyBatis**


使用 Hibernate 或 JPA 操作数据库时，这类 ORM 干的主要工作就是把 ResultSet 的每一行变成 Java Bean，或者把 Java Bean 自动转换到 INSERT 或 UPDATE 语句的参数中，从而实现 ORM。

而 ORM 框架之所以知道如何把行数据映射到 Java Bean，是因为我们在 Java Bean 的属性上给了足够的注解作为元数据，ORM 框架获取 Java Bean 的注解后，就知道如何进行双向映射。

那么，ORM 框架是如何跟踪 Java Bean 的修改，以便在 `update()` 操作中更新必要的属性？

答案是使用 [Proxy 模式](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017)，从 ORM 框架读取的 User 实例实际上并不是 User 类，而是代理类，代理类继承自 User 类，但针对每个 setter 方法做了覆写：

```java
public class UserProxy extends User {
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }
}
```

这样，代理类可以跟踪到每个属性的变化。

针对一对多或多对一关系时，代理类可以直接通过 getter 方法查询数据库：

```java
public class UserProxy extends User {
    Session _session;
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }

    /**
     * 获取 User 对象关联的 Address 对象:
     */
    public Address getAddress() {
        Query q = _session.createQuery("from Address where userId = :userId");
        q.setParameter("userId", this.getId());
        List<Address> list = query.list();
        return list.isEmpty() ? null : list(0);
    }
}
```

为了实现这样的查询，UserProxy 必须保存 Hibernate 的当前 Session。但是，当事务提交后，Session 自动关闭，此时再获取 `getAddress()` 将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM 框架总是引入了 Attached/Detached 状态，表示当前此 Java Bean 到底是在 Session 的范围内，还是脱离了 Session 变成了一个 “游离” 对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的 `PersistentObjectException` 异常。这种隐式状态使得普通 Java Bean 的生命周期变得复杂。

此外，Hibernate 和 JPA 为了实现兼容多种数据库，它使用 HQL 或 JPQL 查询，经过一道转换，变成特定数据库的 SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给 SQL 级别的优化带来了麻烦。

最后，ORM 框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个 Session 范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：

```java
User user1 = session.load(User.class, 123);
User user2 = session.load(User.class, 123);
```

二级缓存是指跨 Session 的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于 SQL 非常灵活，常常会导致意外的更新。例如：

```java
// 线程 1 读取:
User user1 = session1.load(User.class, 123);
...
// 一段时间后，线程 2 读取:
User user2 = session2.load(User.class, 123);
```

当二级缓存生效的时候，两个线程读取的 User 实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：

```sql
-- 给老用户增加 100 积分:
UPDATE users SET bonus = bonus + 100 WHERE createdAt <= ?
```

ORM 无法判断 `id=123` 的用户是否受该 `UPDATE` 语句影响。考虑到数据库通常会支持多个应用程序，此 UPDATE 语句可能由其他进程执行，ORM 框架就更不知道了。

我们把这种 ORM 框架称之为全自动 ORM 框架。

对比 Spring 提供的 JdbcTemplate，它和 ORM 框架相比，主要有几点差别：

1. 查询后需要手动提供 Mapper 实例以便把 ResultSet 的每一行变为 Java 对象；
2. 增删改操作所需的参数列表，需要手动传入，即把 User 实例变为 [user.id, user.name, user.email] 这样的列表，比较麻烦。

但是 JdbcTemplate 的优势在于它的确定性：即每次读取操作一定是数据库操作而不是缓存，所执行的 SQL 是完全确定的，缺点就是代码比较繁琐，构造 `INSERT INTO users VALUES (?,?,?)` 更是复杂。

所以，介于全自动 ORM 如 Hibernate 和手写全部如 JdbcTemplate 之间，还有一种半自动的 ORM，它只负责把 ResultSet 自动映射到 Java Bean，或者自动填充 Java Bean 参数，但仍需自己写出 SQL。[MyBatis](https://mybatis.org/) 就是这样一种半自动化 ORM 框架。

我们来看看如何在 Spring 中集成 MyBatis。

首先，我们要引入 MyBatis 本身，其次，由于 Spring 并没有像 Hibernate 那样内置对 MyBatis 的集成，所以，我们需要再引入 MyBatis 官方自己开发的一个与 Spring 集成的库：

- org.mybatis:mybatis:3.5.11
- org.mybatis:mybatis-spring:3.0.0

和前面一样，先创建 `DataSource` 是必不可少的：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() { ...}
}
```

再回顾一下 Hibernate 和 JPA 的 `SessionFactory` 与 `EntityManagerFactory`，MyBatis 与之对应的是 `SqlSessionFactory` 和 `SqlSession`：

| JDBC       | Hibernate      | JPA                  | MyBatis           |
| :--------- | :------------- | :------------------- | :---------------- |
| DataSource | SessionFactory | EntityManagerFactory | SqlSessionFactory |
| Connection | Session        | EntityManager        | SqlSession        |

可见，ORM 的设计套路都是类似的。使用 MyBatis 的核心就是创建 `SqlSessionFactory`，这里我们需要创建的是 `SqlSessionFactoryBean`：

```java
@Bean
SqlSessionFactoryBean createSqlSessionFactoryBean(@Autowired DataSource dataSource) {
    var sqlSessionFactoryBean = new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
```

因为 MyBatis 可以直接使用 Spring 管理的声明式事务，因此，创建事务管理器和使用 JDBC 是一样的：

```java
@Bean
PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
```

和 Hibernate 不同的是，MyBatis 使用 Mapper 来实现映射，而且 Mapper 必须是接口。我们以 `User` 类为例，在 `User` 类和 `users` 表之间映射的 `UserMapper` 编写如下：

```java
public interface UserMapper {
	@Select("SELECT * FROM users WHERE id = #{id}")
	User getById(@Param("id") long id);
}
```

注意：这里的 Mapper 不是 `JdbcTemplate` 的 `RowMapper` 的概念，它是定义访问 `users` 表的接口方法。比如我们定义了一个 `User getById(long)` 的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的 SQL，这里用注解 `@Select` 标记。SQL 语句的任何参数，都与方法参数按名称对应。例如，方法参数 id 的名字通过注解 `@Param()` 标记为 `id`，则 SQL 语句里将来替换的占位符就是 `#{id}`。

如果有多个参数，那么每个参数命名后直接在 SQL 中写出对应的占位符即可：

```java
@Select("SELECT * FROM users LIMIT #{offset}, #{maxResults}")
List<User> getAll(@Param("offset") int offset, @Param("maxResults") int maxResults);
```

注意：MyBatis 执行查询后，将根据方法的返回类型自动把 ResultSet 的每一行转换为 User 实例，转换规则当然是按列名和属性名对应。如果列名和属性名不同，最简单的方式是编写 SELECT 语句的别名：

```sql
-- 列名是 created_time，属性名是 createdAt:
SELECT id, name, email, created_time AS createdAt FROM users
```

执行 INSERT 语句就稍微麻烦点，因为我们希望传入 User 实例，因此，定义的方法接口与 `@Insert` 注解如下：

```java
@Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
void insert(@Param("user") User user);
```

上述方法传入的参数名称是 `user`，参数类型是 User 类，在 SQL 中引用的时候，以 `#{obj.property}` 的方式写占位符。和 Hibernate 这样的全自动化 ORM 相比，MyBatis 必须写出完整的 INSERT 语句。

如果 `users` 表的 `id` 是自增主键，那么，我们在 SQL 中不传入 `id`，但希望获取插入后的主键，需要再加一个 `@Options` 注解：

```java
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
@Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
void insert(@Param("user") User user);
```

`keyProperty` 和 `keyColumn` 分别指出 JavaBean 的属性和数据库的主键列名。

执行 `UPDATE` 和 `DELETE` 语句相对比较简单，我们定义方法如下：

```java
@Update("UPDATE users SET name = #{user.name}, createdAt = #{user.createdAt} WHERE id = #{user.id}")
void update(@Param("user") User user);

@Delete("DELETE FROM users WHERE id = #{id}")
void deleteById(@Param("id") long id);
```

有了 `UserMapper` 接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但我们除了编写 `UserMapper` 接口外，还有 `BookMapper`、`BonusMapper`…… 一个一个写太麻烦，因此，MyBatis 提供了一个 `MapperFactoryBean` 来自动创建所有 Mapper 的实现类。可以用一个简单的注解来启用它：

```java
@MapperScan("com.itranswarp.learnjava.mapper")
... 其他注解...
public class AppConfig {
    ...
}
```

有了 `@MapperScan`，就可以让 MyBatis 自动扫描指定包的所有 Mapper 并创建实现类。在真正的业务逻辑中，我们可以直接注入：

```java
@Component
@Transactional
public class UserService {
    // 注入 UserMapper:
    @Autowired
    UserMapper userMapper;

    public User getUserById(long id) {
        // 调用 Mapper 方法:
        User user = userMapper.getById(id);
        if (user == null) {
            throw new RuntimeException("User not found by id.");
        }
        return user;
    }
}
```

可见，业务逻辑主要就是通过 `XxxMapper` 定义的数据库方法来访问数据库。

## XML 配置

上述在 Spring 中集成 MyBatis 的方式，我们只需要用到注解，并没有任何 XML 配置文件。MyBatis 也允许使用 XML 配置映射关系和 SQL 语句，例如，更新 `User` 时根据属性值构造动态 SQL：

```xml
<update id="updateUser">
  UPDATE users SET
  <set>
    <if test="user.name != null"> name = #{user.name} </if>
    <if test="user.hobby != null"> hobby = #{user.hobby} </if>
    <if test="user.summary != null"> summary = #{user.summary} </if>
  </set>
  WHERE id = #{user.id}
</update>
```

编写 XML 配置的优点是可以组装出动态 SQL，并且把所有 SQL 操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看 SQL 还需要定位到 XML 配置中。这里我们不介绍 XML 的配置方式，需要了解的童鞋请自行阅读 [官方文档](https://mybatis.org/mybatis-3/zh/configuration.html)。

使用 MyBatis 最大的问题是所有 SQL 都需要全部手写，优点是执行的 SQL 就是我们自己写的 SQL，对 SQL 进行优化非常简单，也可以编写任意复杂的 SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的 SQL。

## 练习


## 小结

MyBatis 是一个半自动化的 ORM 框架，需要手写 SQL 语句，没有自动加载一对多或多对一关系的功能。



# 设计 ORM


我们从前几节可以看到，所谓 ORM，也是建立在 JDBC 的基础上，通过 ResultSet 到 JavaBean 的映射，实现各种查询。有自动跟踪 Entity 修改的全自动化 ORM 如 Hibernate 和 JPA，需要为每个 Entity 创建代理，也有完全自己映射，连 INSERT 和 UPDATE 语句都需要手动编写的 MyBatis，但没有任何透明的 Proxy。

而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种 ORM 解决方案各不相同，Hibernate 和 JPA 自己实现了 HQL 和 JPQL 查询语法，用以生成最终的 SQL，而 MyBatis 则完全手写，每增加一个查询都需要先编写 SQL 并增加接口方法。

还有一种 Hibernate 和 JPA 支持的 Criteria 查询，用 Hibernate 写出来类似：

```java
DetachedCriteria criteria = DetachedCriteria.forClass(User.class);
criteria.add(Restrictions.eq("email", email))
        .add(Restrictions.eq("password", password));
List<User> list = (List<User>) hibernateTemplate.findByCriteria(criteria);
```

上述 Criteria 查询写法复杂，但和 JPA 相比，还是小巫见大巫了：

```java
var cb = em.getCriteriaBuilder();
CriteriaQuery<User> q = cb.createQuery(User.class);
Root<User> r = q.from(User.class);
q.where(cb.equal(r.get("email"), cb.parameter(String.class, "e")));
TypedQuery<User> query = em.createQuery(q);
query.setParameter("e", email);
List<User> list = query.getResultList();
```

此外，是否支持自动读取一对多和多对一关系也是全自动化 ORM 框架的一个重要功能。

如果我们自己来设计并实现一个 ORM，应该吸取这些 ORM 的哪些特色，然后高效实现呢？

## 设计 ORM 接口

任何设计，都必须明确设计目标。这里我们准备实现的 ORM 并不想要全自动 ORM 那种自动读取一对多和多对一关系的功能，也不想给 Entity 加上复杂的状态，因此，对于 Entity 来说，它就是纯粹的 JavaBean，没有任何 Proxy。

此外，ORM 要兼顾易用性和适用性。易用性是指能覆盖 95% 的应用场景，但总有一些复杂的 SQL，很难用 ORM 去自动生成，因此，也要给出原生的 JDBC 接口，能支持 5% 的特殊需求。

最后，我们希望设计的接口要易于编写，并使用流式 API 便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。

以 User 类为例，我们设计的查询接口如下：

```java
// 按主键查询: SELECT * FROM users WHERE id = ?
User u = db.get(User.class, 123);

// 条件查询唯一记录: SELECT * FROM users WHERE email = ? AND password = ?
User u = db.from(User.class)
           .where("email=? AND password=?", "bob@example.com", "bob123")
           .unique();

// 条件查询多条记录: SELECT * FROM users WHERE id < ? ORDER BY email LIMIT ?, ?
List<User> us = db.from(User.class)
                  .where("id < ?", 1000)
                  .orderBy("email")
                  .limit(0, 10)
                  .list();

// 查询特定列: SELECT id, name FROM users WHERE email = ?
User u = db.select("id", "name")
           .from(User.class)
           .where("email = ?", "bob@example.com")
           .unique();
```

这样的流式 API 便于阅读，也非常容易推导出最终生成的 SQL。

对于插入、更新和删除操作，就相对比较简单：

```java
// 插入 User:
db.insert(user);

// 按主键更新更新 User:
db.update(user);

// 按主键删除 User:
db.delete(User.class, 123);
```

对于 Entity 来说，通常一个表对应一个。手动列出所有 Entity 是非常麻烦的，一定要传入 package 自动扫描。

最后，ORM 总是需要元数据才能知道如何映射。我们不想编写复杂的 XML 配置，也没必要自己去定义一套规则，直接使用 JPA 的注解就行。

## 实现 ORM

我们并不需要从 JDBC 底层开始编写，并且，还要考虑到事务，最好能直接使用 Spring 的声明式事务。实际上，我们可以设计一个全局 `DbTemplate`，它注入了 Spring 的 `JdbcTemplate`，涉及到数据库操作时，全部通过 `JdbcTemplate` 完成，自然天生支持 Spring 的声明式事务，因为这个 ORM 只是在 `JdbcTemplate` 的基础上做了一层封装。

在 `AppConfig` 中，我们初始化所有 Bean 如下：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() { ...}

    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    @Bean
    DbTemplate createDbTemplate(@Autowired JdbcTemplate jdbcTemplate) {
        return new DbTemplate(jdbcTemplate, "com.itranswarp.learnjava.entity");
    }

    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

以上就是我们所需的所有配置。

编写业务逻辑，例如 `UserService`，写出来像这样：

```java
@Component
@Transactional
public class UserService {
    @Autowired
    DbTemplate db;

    public User getUserById(long id) {
        return db.get(User.class, id);
    }

    public User getUserByEmail(String email) {
        return db.from(User.class)
                 .where("email = ?", email)
                 .unique();
    }

    public List<User> getUsers(int pageIndex) {
        int pageSize = 100;
        return db.from(User.class)
                 .orderBy("id")
                 .limit((pageIndex - 1) * pageSize, pageSize)
                 .list();
    }

    public User register(String email, String password, String name) {
        User user = new User();
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);
        user.setCreatedAt(System.currentTimeMillis());
        db.insert(user);
        return user;
    }
    ...
}
```

上述代码给出了 ORM 的接口，以及如何在业务逻辑中使用 ORM。下一步，就是如何实现这个 `DbTemplate`。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：

```java
public class DbTemplate {
    private JdbcTemplate jdbcTemplate;

    // 保存 Entity Class 到 Mapper 的映射:
    private Map<Class<?>, Mapper<?>> classMapping;

    public <T> T fetch(Class<T> clazz, Object id) {
        Mapper<T> mapper = getMapper(clazz);
        List<T> list = (List<T>) jdbcTemplate.query(mapper.selectSQL, new Object[] { id }, mapper.rowMapper);
        if (list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }

    public <T> T get(Class<T> clazz, Object id) {
        ...
    }

    public <T> void insert(T bean) {
        ...
    }

    public <T> void update(T bean) {
        ...
    }

    public <T> void delete(Class<T> clazz, Object id) {
        ...
    }
}
```

实现链式 API 的核心代码是第一步从 `DbTemplate` 调用 `select()` 或 `from()` 时实例化一个 `CriteriaQuery` 实例，并在后续的链式调用中设置它的字段：

```java
public class DbTemplate {
    ...
    public Select select(String... selectFields) {
        return new Select(new Criteria(this), selectFields);
    }

    public <T> From<T> from(Class<T> entityClass) {
        Mapper<T> mapper = getMapper(entityClass);
        return new From<>(new Criteria<>(this), mapper);
    }
}
```

然后以此定义 `Select`、`From`、`Where`、`OrderBy`、`Limit` 等。在 `From` 中可以设置 Class 类型、表名等：

```java
public final class From<T> extends CriteriaQuery<T> {
    From(Criteria<T> criteria, Mapper<T> mapper) {
        super(criteria);
        // from 可以设置 class、tableName:
        this.criteria.mapper = mapper;
        this.criteria.clazz = mapper.entityClass;
        this.criteria.table = mapper.tableName;
    }

    public Where<T> where(String clause, Object... args) {
        return new Where<>(this.criteria, clause, args);
    }
}
```

在 `Where` 中可以设置条件参数：

```java
public final class Where<T> extends CriteriaQuery<T> {
    Where(Criteria<T> criteria, String clause, Object... params) {
        super(criteria);
        this.criteria.where = clause;
        this.criteria.whereParams = new ArrayList<>();
        // add:
        for (Object param : params) {
            this.criteria.whereParams.add(param);
        }
    }
}
```

最后，链式调用的尽头是调用 `list()` 返回一组结果，调用 `unique()` 返回唯一结果，调用 `first()` 返回首个结果。

在 IDE 中，可以非常方便地实现链式调用：

![warpdb](./assets/0.gif)

需要复杂查询的时候，总是可以使用 `JdbcTemplate` 执行任意复杂的 SQL。

## 练习


## 小结

ORM 框架就是自动映射数据库表结构到 JavaBean 的工具，设计并实现一个简单高效的 ORM 框架并不困难。

