- [☘️ 使用 Spring MVC](#使用-Spring-MVC)
- [☘️ 使用 REST](#使用-REST)
- [☘️ 集成 Filter](#集成-Filter)
- [☘️ 使用 Interceptor](#使用-Interceptor)
- [☘️ 处理 CORS](#处理-CORS)
- [☘️ 国际化](#国际化)
- [☘️ 异步处理](#异步处理)
- [☘️ 使用 WebSocket](#使用-WebSocket)



# 开发 Web 应用


在 [Web 开发](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400) 一章中，我们已经详细介绍了 JavaEE 中 Web 开发的基础：Servlet。具体地说，有以下几点：

1. Servlet 规范定义了几种标准组件：Servlet、JSP、Filter 和 Listener；
2. Servlet 的标准组件总是运行在 Servlet 容器中，如 Tomcat、Jetty、WebLogic 等。

直接使用 Servlet 进行 Web 开发好比直接在 JDBC 上操作数据库，比较繁琐，更好的方法是在 Servlet 基础上封装 MVC 框架，基于 MVC 开发 Web 应用，大部分时候，不需要接触 Servlet API，开发省时省力。

我们在 [MVC 开发](https://www.liaoxuefeng.com/wiki/1252599548343744/1266264917931808) 和[MVC 高级开发](https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009)已经由浅入深地介绍了如何编写 MVC 框架。当然，自己写的 MVC 主要是理解原理，要实现一个功能全面的 MVC 需要大量的工作以及广泛的测试。

因此，开发 Web 应用，首先要选择一个优秀的 MVC 框架。常用的 MVC 框架有：

- [Struts](https://struts.apache.org/)：最古老的一个 MVC 框架，目前版本是 2，和 1.x 有很大的区别；
- WebWork：一个比 Struts 设计更优秀的 MVC 框架，但不知道出于什么原因，从 2.0 开始把自己的代码全部塞给 Struts 2 了；
- [Turbine](https://turbine.apache.org/)：一个重度使用 Velocity，强调布局的 MVC 框架；
- 其他 100+MVC 框架……（略）

Spring 虽然都可以集成任何 Web 框架，但是，Spring 本身也开发了一个 MVC 框架，就叫 [Spring MVC](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)。这个 MVC 框架设计得足够优秀以至于我们已经不想再费劲去集成类似 Struts 这样的框架了。

本章我们会详细介绍如何基于 Spring MVC 开发 Web 应用。



# 使用 Spring MVC

Last updated: 2022/11/16 21:43 / Reads: 1902347

------

我们在前面介绍 [Web 开发](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400) 时已经讲过了 Java Web 的基础：Servlet 容器，以及标准的 Servlet 组件：

- Servlet：能处理 HTTP 请求并将 HTTP 响应返回；
- JSP：一种嵌套 Java 代码的 HTML，将被编译为 Servlet；
- Filter：能过滤指定的 URL 以实现拦截功能；
- Listener：监听指定的事件，如 ServletContext、HttpSession 的创建和销毁。

此外，Servlet 容器为每个 Web 应用程序自动创建一个唯一的 `ServletContext` 实例，这个实例就代表了 Web 应用程序本身。

在 [MVC 高级开发](https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009) 中，我们手撸了一个 MVC 框架，接口和 Spring MVC 类似。如果直接使用 Spring MVC，我们写出来的代码类似：

```
@Controller
public class UserController {
    @GetMapping("/register")
    public ModelAndView register() {
        ...
    }

    @PostMapping("/signin")
    public ModelAndView signin(@RequestParam("email") String email, @RequestParam("password") String password) {
        ...
    }
    ...
}
```

但是，Spring 提供的是一个 IoC 容器，所有的 Bean，包括 Controller，都在 Spring IoC 容器中被初始化，而 Servlet 容器由 JavaEE 服务器提供（如 Tomcat），Servlet 容器对 Spring 一无所知，他们之间到底依靠什么进行联系，又是以何种顺序初始化的？

在理解上述问题之前，我们先把基于 Spring MVC 开发的项目结构搭建起来。首先创建基于 Web 的 Maven 工程，引入如下依赖：

- org.springframework:spring-context:6.0.0
- org.springframework:spring-webmvc:6.0.0
- org.springframework:spring-jdbc:6.0.0
- jakarta.annotation:jakarta.annotation-api:2.1.1
- io.pebbletemplates:pebble-spring6:3.2.0
- ch.qos.logback:logback-core:1.4.4
- ch.qos.logback:logback-classic:1.4.4
- com.zaxxer:HikariCP:5.0.1
- org.hsqldb:hsqldb:2.7.0

以及 `provided` 依赖：

- org.apache.tomcat.embed:tomcat-embed-core:10.1.1
- org.apache.tomcat.embed:tomcat-embed-jasper:10.1.1

这个标准的 Maven Web 工程目录结构如下：

```ascii
spring-web-mvc
├── pom.xml
└── src
    └── main
        ├── java
        │   └── com
        │       └── itranswarp
        │           └── learnjava
        │               ├── AppConfig.java
        │               ├── DatabaseInitializer.java
        │               ├── entity
        │               │   └── User.java
        │               ├── service
        │               │   └── UserService.java
        │               └── web
        │                   └── UserController.java
        ├── resources
        │   ├── jdbc.properties
        │   └── logback.xml
        └── webapp
            ├── WEB-INF
            │   ├── templates
            │   │   ├── _base.html
            │   │   ├── index.html
            │   │   ├── profile.html
            │   │   ├── register.html
            │   │   └── signin.html
            │   └── web.xml
            └── static
                ├── css
                │   └── bootstrap.css
                └── js
                    └── jquery.js
```

其中，`src/main/webapp` 是标准 web 目录，`WEB-INF` 存放 `web.xml`，编译的 class，第三方 jar，以及不允许浏览器直接访问的 View 模版，`static` 目录存放所有静态文件。

在 `src/main/resources` 目录中存放的是 Java 程序读取的 classpath 资源文件，除了 JDBC 的配置文件 `jdbc.properties` 外，我们又新增了一个 `logback.xml`，这是 Logback 的默认查找的配置文件：

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<appender name="STDOUT"
		class="ch.qos.logback.core.ConsoleAppender">
		<layout class="ch.qos.logback.classic.PatternLayout">
			<Pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</Pattern>
		</layout>
	</appender>

	<logger name="com.itranswarp.learnjava" level="info" additivity="false">
		<appender-ref ref="STDOUT" />
	</logger>

	<root level="info">
		<appender-ref ref="STDOUT" />
	</root>
</configuration>
```

上面给出了一个写入到标准输出的 Logback 配置，可以基于上述配置添加写入到文件的配置。

在 `src/main/java` 中就是我们编写的 Java 代码了。

### 配置 Spring MVC

和普通 Spring 配置一样，我们编写正常的 `AppConfig` 后，只需加上 `@EnableWebMvc` 注解，就 “激活” 了 Spring MVC：

```
@Configuration
@ComponentScan
@EnableWebMvc // 启用 Spring MVC
@EnableTransactionManagement
@PropertySource("classpath:/jdbc.properties")
public class AppConfig {
    ...
}
```

除了创建 `DataSource`、`JdbcTemplate`、`PlatformTransactionManager` 外，`AppConfig` 需要额外创建几个用于 Spring MVC 的 Bean：

```
@Bean
WebMvcConfigurer createWebMvcConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
            registry.addResourceHandler("/static/**").addResourceLocations("/static/");
        }
    };
}
```

`WebMvcConfigurer` 并不是必须的，但我们在这里创建一个默认的 `WebMvcConfigurer`，只覆写 `addResourceHandlers()`，目的是让 Spring MVC 自动处理静态文件，并且映射路径为 `/static/**`。

另一个必须要创建的 Bean 是 `ViewResolver`，因为 Spring MVC 允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的 `ViewResolver`：

```
@Bean
ViewResolver createViewResolver(@Autowired ServletContext servletContext) {
    var engine = new PebbleEngine.Builder().autoEscaping(true)
            // cache:
            .cacheActive(false)
            // loader:
            .loader(new Servlet5Loader(servletContext))
            .build();
    var viewResolver = new PebbleViewResolver(engine);
    viewResolver.setPrefix("/WEB-INF/templates/");
    viewResolver.setSuffix("");
    return viewResolver;
}
```

`ViewResolver` 通过指定 `prefix` 和 `suffix` 来确定如何查找 View。上述配置使用 Pebble 引擎，指定模板文件存放在 `/WEB-INF/templates/` 目录下。

剩下的 Bean 都是普通的 `@Component`，但 Controller 必须标记为 `@Controller`，例如：

```
// Controller 使用 @Controller 标记而不是 @Component:
@Controller
public class UserController {
    // 正常使用 @Autowired 注入:
    @Autowired
    UserService userService;

    // 处理一个 URL 映射:
    @GetMapping("/")
    public ModelAndView index() {
        ...
    }
    ...
}
```

如果是普通的 Java 应用程序，我们通过 `main()` 方法可以很简单地创建一个 Spring 容器的实例：

```
public static void main(String[] args) {
    var context = new AnnotationConfigApplicationContext(AppConfig.class);
}
```

但是问题来了，现在是 Web 应用程序，而 Web 应用程序总是由 Servlet 容器创建，那么，Spring 容器应该由谁创建？在什么时候创建？Spring 容器中的 Controller 又是如何通过 Servlet 调用的？

在 Web 应用中启动 Spring 容器有很多种方法，可以通过 Listener 启动，也可以通过 Servlet 启动，可以使用 XML 配置，也可以使用注解配置。这里，我们只介绍一种 * 最简单 * 的启动 Spring 容器的方式。

第一步，我们在 `web.xml` 中配置 Spring MVC 提供的 `DispatcherServlet`：

```
<?xml version="1.0"?>
<web-app>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
        </init-param>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.itranswarp.learnjava.AppConfig</param-value>
        </init-param>
        <load-on-startup>0</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>
```

初始化参数 `contextClass` 指定使用注解配置的 `AnnotationConfigWebApplicationContext`，配置文件的位置参数 `contextConfigLocation` 指向 `AppConfig` 的完整类名，最后，把这个 Servlet 映射到 `/*`，即处理所有 URL。

上述配置可以看作一个样板配置，有了这个配置，Servlet 容器会首先初始化 Spring MVC 的 `DispatcherServlet`，在 `DispatcherServlet` 启动时，它根据配置 `AppConfig` 创建了一个类型是 `WebApplicationContext` 的 IoC 容器，完成所有 Bean 的初始化，并将容器绑到 `ServletContext` 上。

因为 `DispatcherServlet` 持有 IoC 容器，能从 IoC 容器中获取所有 `@Controller` 的 Bean，因此，`DispatcherServlet` 接收到所有 HTTP 请求后，根据 Controller 方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的 `ModelAndView` 决定如何渲染页面。

最后，我们在 `AppConfig` 中通过 `main()` 方法启动嵌入式 Tomcat：

```
public static void main(String[] args) throws Exception {
    Tomcat tomcat = new Tomcat();
    tomcat.setPort(Integer.getInteger("port", 8080));
    tomcat.getConnector();
    Context ctx = tomcat.addWebapp("", new File("src/main/webapp").getAbsolutePath());
    WebResourceRoot resources = new StandardRoot(ctx);
    resources.addPreResources(
            new DirResourceSet(resources, "/WEB-INF/classes", new File("target/classes").getAbsolutePath(), "/"));
    ctx.setResources(resources);
    tomcat.start();
    tomcat.getServer().await();
}
```

上述 Web 应用程序就是我们使用 Spring MVC 时的一个最小启动功能集。由于使用了 JDBC 和数据库，用户的注册、登录信息会被持久化：

![spring-mvc](./assets/l-20231221154251203.png)

### 编写 Controller

有了 Web 应用程序的最基本的结构，我们的重点就可以放在如何编写 Controller 上。Spring MVC 对 Controller 没有固定的要求，也不需要实现特定的接口。以 `UserController` 为例，编写 Controller 只需要遵循以下要点：

总是标记 `@Controller` 而不是 `@Component`：

```
@Controller
public class UserController {
    ...
}
```

一个方法对应一个 HTTP 请求路径，用 `@GetMapping` 或 `@PostMapping` 表示 GET 或 POST 请求：

```
@PostMapping("/signin")
public ModelAndView doSignin(
        @RequestParam("email") String email,
        @RequestParam("password") String password,
        HttpSession session) {
    ...
}
```

需要接收的 HTTP 参数以 `@RequestParam()` 标注，可以设置默认值。如果方法参数需要传入 `HttpServletRequest`、`HttpServletResponse` 或者 `HttpSession`，直接添加这个类型的参数即可，Spring MVC 会自动按类型传入。

返回的 ModelAndView 通常包含 View 的路径和一个 Map 作为 Model，但也可以没有 Model，例如：

```
return new ModelAndView("signin.html"); // 仅 View，没有 Model
```

返回重定向时既可以写 `new ModelAndView("redirect:/signin")`，也可以直接返回 String：

```
public String index() {
    if (...) {
        return "redirect:/signin";
    } else {
        return "redirect:/profile";
    }
}
```

如果在方法内部直接操作 `HttpServletResponse` 发送响应，返回 `null` 表示无需进一步处理：

```
public ModelAndView download(HttpServletResponse response) {
    byte[] data = ...
    response.setContentType("application/octet-stream");
    OutputStream output = response.getOutputStream();
    output.write(data);
    output.flush();
    return null;
}
```

对 URL 进行分组，每组对应一个 Controller 是一种很好的组织形式，并可以在 Controller 的 class 定义出添加 URL 前缀，例如：

```
@Controller
@RequestMapping("/user")
public class UserController {
    // 注意实际 URL 映射是 / user/profile
    @GetMapping("/profile")
    public ModelAndView profile() {
        ...
    }

    // 注意实际 URL 映射是 / user/changePassword
    @GetMapping("/changePassword")
    public ModelAndView changePassword() {
        ...
    }
}
```

实际方法的 URL 映射总是前缀 + 路径，这种形式还可以有效避免不小心导致的重复的 URL 映射。

可见，Spring MVC 允许我们编写既简单又灵活的 Controller 实现。

### 练习

在注册、登录等功能的基础上增加一个修改口令的页面。

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[使用 Spring MVC](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/10. 使用 Spring MVC.1282383921807393/spring-web-mvc.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

使用 Spring MVC 时，整个 Web 应用程序按如下顺序启动：

1. 启动 Tomcat 服务器；
2. Tomcat 读取 `web.xml` 并初始化 `DispatcherServlet`；
3. `DispatcherServlet` 创建 IoC 容器并自动注册到 `ServletContext` 中。

启动后，浏览器发出的 HTTP 请求全部由 `DispatcherServlet` 接收，并根据配置转发到指定 Controller 的指定方法处理。



# 使用 REST

Last updated: 2022/11/16 22:13 / Reads: 385965

------

使用 Spring MVC 开发 Web 应用程序的主要工作就是编写 Controller 逻辑。在 Web 应用中，除了需要使用 MVC 给用户显示页面外，还有一类 API 接口，我们称之为 REST，通常输入输出都是 JSON，便于第三方调用或者使用页面 JavaScript 与之交互。

直接在 Controller 中处理 JSON 是可以的，因为 Spring MVC 的 `@GetMapping` 和 `@PostMapping` 都支持指定输入和输出的格式。如果我们想接收 JSON，输出 JSON，那么可以这样写：

```
@PostMapping(value = "/rest",
             consumes = "application/json;charset=UTF-8",
             produces = "application/json;charset=UTF-8")
@ResponseBody
public String rest(@RequestBody User user) {
    return "{\"restSupport\":true}";
}
```

对应的 Maven 工程需要加入 Jackson 这个依赖：`com.fasterxml.jackson.core:jackson-databind:2.14.0`

注意到 `@PostMapping` 使用 `consumes` 声明能接收的类型，使用 `produces` 声明输出的类型，并且额外加了 `@ResponseBody` 表示返回的 `String` 无需额外处理，直接作为输出内容写入 `HttpServletResponse`。输入的 JSON 则根据注解 `@RequestBody` 直接被 Spring 反序列化为 `User` 这个 JavaBean。

使用 curl 命令测试一下：

```
$ curl -v -H "Content-Type: application/json" -d '{"email":"bob@example.com"}' http://localhost:8080/rest
> POST /rest HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.64.1
> Accept: */*
> Content-Type: application/json
> Content-Length: 27
>
< HTTP/1.1 200
< Content-Type: application/json;charset=utf-8
< Content-Length: 20
< Date: Sun, 10 May 2020 09:56:01 GMT
<
{"restSupport":true}
```

输出正是我们写入的字符串。

直接用 Spring 的 Controller 配合一大堆注解写 REST 太麻烦了，因此，Spring 还额外提供了一个 `@RestController` 注解，使用 `@RestController` 替代 `@Controller` 后，每个方法自动变成 API 接口方法。我们还是以实际代码举例，编写 `ApiController` 如下：

```
@RestController
@RequestMapping("/api")
public class ApiController {
    @Autowired
    UserService userService;

    @GetMapping("/users")
    public List<User> users() {
        return userService.getUsers();
    }

    @GetMapping("/users/{id}")
    public User user(@PathVariable("id") long id) {
        return userService.getUserById(id);
    }

    @PostMapping("/signin")
    public Map<String, Object> signin(@RequestBody SignInRequest signinRequest) {
        try {
            User user = userService.signin(signinRequest.email, signinRequest.password);
            return Map.of("user", user);
        } catch (Exception e) {
            return Map.of("error", "SIGNIN_FAILED", "message", e.getMessage());
        }
    }

    public static class SignInRequest {
        public String email;
        public String password;
    }
}
```

编写 REST 接口只需要定义 `@RestController`，然后，每个方法都是一个 API 接口，输入和输出只要能被 Jackson 序列化或反序列化为 JSON 就没有问题。我们用浏览器测试 GET 请求，可直接显示 JSON 响应：

![user-api](./assets/l-20231221154305694.png)

要测试 POST 请求，可以用 curl 命令：

```
$ curl -v -H "Content-Type: application/json" -d '{"email":"bob@example.com","password":"bob123"}' http://localhost:8080/api/signin
> POST /api/signin HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.64.1
> Accept: */*
> Content-Type: application/json
> Content-Length: 47
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Sun, 10 May 2020 08:14:13 GMT
<
{"user":{"id":1,"email":"bob@example.com","password":"bob123","name":"Bob",...
```

注意观察上述 JSON 的输出，`User` 能被正确地序列化为 JSON，但暴露了 `password` 属性，这是我们不期望的。要避免输出 `password` 属性，可以把 `User` 复制到另一个 `UserBean` 对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在 `User` 的 `password` 属性定义处加上 `@JsonIgnore` 表示完全忽略该属性：

```
public class User {
    ...

    @JsonIgnore
    public String getPassword() {
        return password;
    }

    ...
}
```

但是这样一来，如果写一个 `register(User user)` 方法，那么该方法的 User 对象也拿不到注册时用户传入的密码了。如果要允许输入 `password`，但不允许输出 `password`，即在 JSON 序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：

```
public class User {
    ...

    @JsonProperty(access = Access.WRITE_ONLY)
    public String getPassword() {
        return password;
    }

    ...
}
```

同样的，可以使用 `@JsonProperty(access = Access.READ_ONLY)` 允许输出，不允许输入。

### 练习

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[使用 REST 实现 API](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/20. 使用 REST.1282384941023266/spring-web-mvc-rest.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

使用 `@RestController` 可以方便地编写 REST 服务，Spring 默认使用 JSON 作为输入和输出。

要控制序列化和反序列化，可以使用 Jackson 提供的 `@JsonIgnore` 和 `@JsonProperty` 注解。



# 集成 Filter

Last updated: 2019/5/18 17:53 / Reads: 256288

------

在 Spring MVC 中，`DispatcherServlet` 只需要固定配置到 `web.xml` 中，剩下的工作主要是专注于编写 Controller。

但是，在 Servlet 规范中，我们还可以 [使用 Filter](https://www.liaoxuefeng.com/wiki/1252599548343744/1266264823560128)。如果要在 Spring MVC 中使用 `Filter`，应该怎么做？

有的童鞋在上一节的 Web 应用中可能发现了，如果注册时输入中文会导致乱码，因为 Servlet 默认按非 UTF-8 编码读取参数。为了修复这一问题，我们可以简单地使用一个 EncodingFilter，在全局范围类给 `HttpServletRequest` 和 `HttpServletResponse` 强制设置为 UTF-8 编码。

可以自己编写一个 EncodingFilter，也可以直接使用 Spring MVC 自带的一个 `CharacterEncodingFilter`。配置 Filter 时，只需在 `web.xml` 中声明即可：

```
<web-app>
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>

    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

因为这种 Filter 和我们业务关系不大，注意到 `CharacterEncodingFilter` 其实和 Spring 的 IoC 容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种 Filter 十分简单。

我们再考虑这样一个问题：如果允许用户使用 Basic 模式进行用户验证，即在 HTTP 请求中添加头 `Authorization: Basic email:password`，这个需求如何实现？

编写一个 `AuthFilter` 是最简单的实现方式：

```
@Component
public class AuthFilter implements Filter {
    @Autowired
    UserService userService;

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        // 获取 Authorization 头:
        String authHeader = req.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Basic")) {
            // 从 Header 中提取 email 和 password:
            String email = prefixFrom(authHeader);
            String password = suffixFrom(authHeader);
            // 登录:
            User user = userService.signin(email, password);
            // 放入 Session:
            req.getSession().setAttribute(UserController.KEY_USER, user);
        }
        // 继续处理请求:
        chain.doFilter(request, response);
    }
}
```

现在问题来了：在 Spring 中创建的这个 `AuthFilter` 是一个普通 Bean，Servlet 容器并不知道，所以它不会起作用。

如果我们直接在 `web.xml` 中声明这个 `AuthFilter`，注意到 `AuthFilter` 的实例将由 Servlet 容器而不是 Spring 容器初始化，因此，`@Autowire` 根本不生效，用于登录的 `UserService` 成员变量永远是 `null`。

所以，得通过一种方式，让 Servlet 容器实例化的 Filter，间接引用 Spring 容器实例化的 `AuthFilter`。Spring MVC 提供了一个 `DelegatingFilterProxy`，专门来干这个事情：

```
<web-app>
    <filter>
        <filter-name>authFilter</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>

    <filter-mapping>
        <filter-name>authFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

我们来看实现原理：

1. Servlet 容器从 `web.xml` 中读取配置，实例化 `DelegatingFilterProxy`，注意命名是 `authFilter`；
2. Spring 容器通过扫描 `@Component` 实例化 `AuthFilter`。

当 `DelegatingFilterProxy` 生效后，它会自动查找注册在 `ServletContext` 上的 Spring 容器，再试图从容器中查找名为 `authFilter` 的 Bean，也就是我们用 `@Component` 声明的 `AuthFilter`。

`DelegatingFilterProxy` 将请求代理给 `AuthFilter`，核心代码如下：

```
public class DelegatingFilterProxy implements Filter {
    private Filter delegate;
    public void doFilter(...) throws ... {
        if (delegate == null) {
            delegate = findBeanFromSpringContainer();
        }
        delegate.doFilter(req, resp, chain);
    }
}
```

这就是一个 [代理模式](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017) 的简单应用。我们画个图表示它们之间的引用关系如下：

```ascii
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
  ┌─────────────────────┐        ┌───────────┐   │
│ │DelegatingFilterProxy│─│─│─ ─>│AuthFilter │
  └─────────────────────┘        └───────────┘   │
│ ┌─────────────────────┐ │ │    ┌───────────┐
  │  DispatcherServlet  │─ ─ ─ ─>│Controllers│   │
│ └─────────────────────┘ │ │    └───────────┘
                                                 │
│    Servlet Container    │ │  Spring Container
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

如果在 `web.xml` 中配置的 Filter 名字和 Spring 容器的 Bean 的名字不一致，那么需要指定 Bean 的名字：

```
<filter>
    <filter-name>basicAuthFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    <!-- 指定 Bean 的名字 -->
    <init-param>
        <param-name>targetBeanName</param-name>
        <param-value>authFilter</param-value>
    </init-param>
</filter>
```

实际应用时，尽量保持名字一致，以减少不必要的配置。

要使用 Basic 模式的用户认证，我们可以使用 curl 命令测试。例如，用户登录名是 `tom@example.com`，口令是 `tomcat`，那么先构造一个使用 URL 编码的 ` 用户名: 口令 ` 的字符串：

```
tom%40example.com:tomcat
```

对其进行 Base64 编码，最终构造出的 Header 如下：

```
Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0
```

使用如下的 `curl` 命令并获得响应如下：

```
$ curl -v -H 'Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0' http://localhost:8080/profile
> GET /profile HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.64.1
> Accept: */*
> Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0
>
< HTTP/1.1 200
< Set-Cookie: JSESSIONID=CE0F4BFC394816F717443397D4FEABBE; Path=/; HttpOnly
< Content-Type: text/html;charset=UTF-8
< Content-Language: en-CN
< Transfer-Encoding: chunked
< Date: Wed, 29 Apr 2020 00:15:50 GMT
<
<!doctype html>
...HTML 输出...
```

上述响应说明 `AuthFilter` 已生效。

 注意：Basic 认证模式并不安全，本节只用来作为使用 Filter 的示例。

### 练习

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[使用 DelegatingFilterProxy 实现 AuthFilter](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/30. 集成 Filter.1282384114745378/spring-web-mvc-filter.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

当一个 Filter 作为 Spring 容器管理的 Bean 存在时，可以通过 `DelegatingFilterProxy` 间接地引用它并使其生效。



# 使用 Interceptor

Last updated: 2020/5/10 08:29 / Reads: 431412

------

在 Web 程序中，注意到使用 Filter 的时候，Filter 由 Servlet 容器管理，它在 Spring MVC 的 Web 应用程序中作用范围如下：

```ascii
         │   ▲
         ▼   │
       ┌───────┐
       │Filter1│
       └───────┘
         │   ▲
         ▼   │
       ┌───────┐
┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐
       └───────┘
│        │   ▲                  │
         ▼   │
│ ┌─────────────────┐           │
  │DispatcherServlet│<───┐
│ └─────────────────┘    │      │
   │              ┌────────────┐
│  │              │ModelAndView││
   │              └────────────┘
│  │                     ▲      │
   │    ┌───────────┐    │
│  ├───>│Controller1│────┤      │
   │    └───────────┘    │
│  │                     │      │
   │    ┌───────────┐    │
│  └───>│Controller2│────┘      │
        └───────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

上图虚线框就是 Filter2 的拦截范围，Filter 组件实际上并不知道后续内部处理是通过 Spring MVC 提供的 `DispatcherServlet` 还是其他 Servlet 组件，因为 Filter 是 Servlet 规范定义的标准组件，它可以应用在任何基于 Servlet 的程序中。

如果只基于 Spring MVC 开发应用程序，还可以使用 Spring MVC 提供的一种功能类似 Filter 的拦截器：Interceptor。和 Filter 相比，Interceptor 拦截范围不是后续整个处理流程，而是仅针对 Controller 拦截：

```ascii
       │   ▲
       ▼   │
     ┌───────┐
     │Filter1│
     └───────┘
       │   ▲
       ▼   │
     ┌───────┐
     │Filter2│
     └───────┘
       │   ▲
       ▼   │
┌─────────────────┐
│DispatcherServlet│<───┐
└─────────────────┘    │
 │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ┐
 │                     │
 │ │            ┌────────────┐ │
 │              │   Render   │
 │ │            └────────────┘ │
 │                     ▲
 │ │                   │       │
 │              ┌────────────┐
 │ │            │ModelAndView│ │
 │              └────────────┘
 │ │                   ▲       │
 │    ┌───────────┐    │
 ├─┼─>│Controller1│────┤       │
 │    └───────────┘    │
 │ │                   │       │
 │    ┌───────────┐    │
 └─┼─>│Controller2│────┘       │
      └───────────┘
   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

上图虚线框就是 Interceptor 的拦截范围，注意到 Controller 的处理方法一般都类似这样：

```
@Controller
public class Controller1 {
    @GetMapping("/path/to/hello")
    ModelAndView hello() {
        ...
    }
}
```

所以，Interceptor 的拦截范围其实就是 Controller 方法，它实际上就相当于基于 AOP 的方法拦截。因为 Interceptor 只拦截 Controller 方法，所以要注意，返回 `ModelAndView` 并渲染后，后续处理就脱离了 Interceptor 的拦截范围。

使用 Interceptor 的好处是 Interceptor 本身是 Spring 管理的 Bean，因此注入任意 Bean 都非常简单。此外，可以应用多个 Interceptor，并通过简单的 `@Order` 指定顺序。我们先写一个 `LoggerInterceptor`：

```
@Order(1)
@Component
public class LoggerInterceptor implements HandlerInterceptor {

    final Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.info("preHandle {}...", request.getRequestURI());
        if (request.getParameter("debug") != null) {
            PrintWriter pw = response.getWriter();
            pw.write("<p>DEBUG MODE</p>");
            pw.flush();
            return false;
        }
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.info("postHandle {}.", request.getRequestURI());
        if (modelAndView != null) {
            modelAndView.addObject("__time__", LocalDateTime.now());
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.info("afterCompletion {}: exception = {}", request.getRequestURI(), ex);
    }
}
```

一个 Interceptor 必须实现 `HandlerInterceptor` 接口，可以选择实现 `preHandle()`、`postHandle()` 和 `afterCompletion()` 方法。`preHandle()` 是 Controller 方法调用前执行，`postHandle()` 是 Controller 方法正常返回后执行，而 `afterCompletion()` 无论 Controller 方法是否抛异常都会执行，参数 `ex` 就是 Controller 方法抛出的异常（未抛出异常是 `null`）。

在 `preHandle()` 中，也可以直接处理响应，然后返回 `false` 表示无需调用 Controller 方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在 `postHandle()` 中，因为捕获了 Controller 方法返回的 `ModelAndView`，所以可以继续往 `ModelAndView` 里添加一些通用数据，很多页面需要的全局数据如 Copyright 信息等都可以放到这里，无需在每个 Controller 方法中重复添加。

我们再继续添加一个 `AuthInterceptor`，用于替代上一节使用 `AuthFilter` 进行 Basic 认证的功能：

```
@Order(2)
@Component
public class AuthInterceptor implements HandlerInterceptor {

    final Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        logger.info("pre authenticate {}...", request.getRequestURI());
        try {
            authenticateByHeader(request);
        } catch (RuntimeException e) {
            logger.warn("login by authorization header failed.", e);
        }
        return true;
    }

    private void authenticateByHeader(HttpServletRequest req) {
        String authHeader = req.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Basic")) {
            logger.info("try authenticate by authorization header...");
            String up = new String(Base64.getDecoder().decode(authHeader.substring(6)), StandardCharsets.UTF_8);
            int pos = up.indexOf(':');
            if (pos> 0) {
                String email = URLDecoder.decode(up.substring(0, pos), StandardCharsets.UTF_8);
                String password = URLDecoder.decode(up.substring(pos + 1), StandardCharsets.UTF_8);
                User user = userService.signin(email, password);
                req.getSession().setAttribute(UserController.KEY_USER, user);
                logger.info("user {} login by authorization header ok.", email);
            }
        }
    }
}
```

这个 `AuthInterceptor` 是由 Spring 容器直接管理的，因此注入 `UserService` 非常方便。

最后，要让拦截器生效，我们在 `WebMvcConfigurer` 中注册所有的 Interceptor：

```
@Bean
WebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) {
    return new WebMvcConfigurer() {
        public void addInterceptors(InterceptorRegistry registry) {
            for (var interceptor : interceptors) {
                registry.addInterceptor(interceptor);
            }
        }
        ...
    };
}
```

 如果拦截器没有生效，请检查是否忘了在 WebMvcConfigurer 中注册。

### 处理异常

在 Controller 中，Spring MVC 还允许定义基于 `@ExceptionHandler` 注解的异常处理方法。我们来看具体的示例代码：

```
@Controller
public class UserController {
    @ExceptionHandler(RuntimeException.class)
    public ModelAndView handleUnknowException(Exception ex) {
        return new ModelAndView("500.html", Map.of("error", ex.getClass().getSimpleName(), "message", ex.getMessage()));
    }
    ...
}
```

异常处理方法没有固定的方法签名，可以传入 `Exception`、`HttpServletRequest` 等，返回值可以是 `void`，也可以是 `ModelAndView`，上述代码通过 `@ExceptionHandler(RuntimeException.class)` 表示当发生 `RuntimeException` 的时候，就自动调用此方法处理。

注意到我们返回了一个新的 `ModelAndView`，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的 500 Internal Server Error 或 404 Not Found。例如 B 站的错误页：

![500](./assets/l-20231221154335517.png)

可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理 `LoginException` 使得页面可以自动跳转到登录页。

使用 `ExceptionHandler` 时，要注意它仅作用于当前的 Controller，即 ControllerA 中定义的一个 `ExceptionHandler` 方法对 ControllerB 不起作用。如果我们有很多 Controller，每个 Controller 都需要处理一些通用的异常，例如 `LoginException`，思考一下应该怎么避免重复代码？

### 练习

从 [![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=)](https://gitee.com/) 下载练习：[使用 Interceptor](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/40. 使用 Interceptor.1347180610715681/spring-web-mvc-interceptor.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

Spring MVC 提供了 Interceptor 组件来拦截 Controller 方法，使用时要注意 Interceptor 的作用范围。



# 处理 CORS

Last updated: 2019/5/18 17:55 / Reads: 192197

------

在开发 REST 应用时，很多时候，是通过页面的 JavaScript 和后端的 REST API 交互。

在 JavaScript 与 REST 交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行 JavaScript 调用 API，即：

- 如果 A 站在域名 `a.com` 页面的 JavaScript 调用 A 站自己的 API 时，没有问题；
- 如果 A 站在域名 `a.com` 页面的 JavaScript 调用 B 站 `b.com` 的 API 时，将被浏览器拒绝访问，因为不满足同源策略。

同源要求域名要完全相同（`a.com` 和 `www.a.com` 不同），协议要相同（`http` 和 `https` 不同），端口要相同 。

那么，在域名 `a.com` 页面的 JavaScript 要调用 B 站 `b.com` 的 API 时，还有没有办法？

办法是有的，那就是 CORS，全称 Cross-Origin Resource Sharing，是 HTML5 规范定义的如何跨域访问资源。如果 A 站的 JavaScript 访问 B 站 API 的时候，B 站能够返回响应头 `Access-Control-Allow-Origin: http://a.com`，那么，浏览器就允许 A 站的 JavaScript 访问 B 站的 API。

注意到跨域访问能否成功，取决于 B 站是否愿意给 A 站返回一个正确的 `Access-Control-Allow-Origin` 响应头，所以决定权永远在提供 API 的服务方手中。

关于 CORS 的详细信息可以参考 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)，这里不再详述。

使用 Spring 的 `@RestController` 开发 REST 应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面 JavaScript 访问这些 REST API，就必须正确地设置 CORS。

有好几种方法设置 CORS，我们来一一介绍。

### 使用 @CrossOrigin

第一种方法是使用 `@CrossOrigin` 注解，可以在 `@RestController` 的 class 级别或方法级别定义一个 `@CrossOrigin`，例如：

```
@CrossOrigin(origins = "http://local.liaoxuefeng.com:8080")
@RestController
@RequestMapping("/api")
public class ApiController {
    ...
}
```

上述定义在 `ApiController` 处的 `@CrossOrigin` 指定了只允许来自 `local.liaoxuefeng.com` 跨域访问，允许多个域访问需要写成数组形式，例如 `origins = {"http://a.com", "https://www.b.com"})`。如果要允许任何域访问，写成 `origins = "*"` 即可。

如果有多个 REST Controller 都需要使用 CORS，那么，每个 Controller 都必须标注 `@CrossOrigin` 注解。

### 使用 CorsRegistry

第二种方法是在 `WebMvcConfigurer` 中定义一个全局 CORS 配置，下面是一个示例：

```
@Bean
WebMvcConfigurer createWebMvcConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping("/api/**")
                    .allowedOrigins("http://local.liaoxuefeng.com:8080")
                    .allowedMethods("GET", "POST")
                    .maxAge(3600);
            // 可以继续添加其他 URL 规则:
            // registry.addMapping("/rest/v2/**")...
        }
    };
}
```

这种方式可以创建一个全局 CORS 配置，如果仔细地设计 URL 结构，那么可以一目了然地看到各个 URL 的 CORS 规则，推荐使用这种方式配置 CORS。

### 使用 CorsFilter

第三种方法是使用 Spring 提供的 `CorsFilter`，我们在 [集成 Filter](https://www.liaoxuefeng.com/wiki/1252599548343744/1282384114745378/) 中详细介绍了将 Spring 容器内置的 Bean 暴露为 Servlet 容器的 Filter 的方法，由于这种配置方式需要修改 `web.xml`，也比较繁琐，所以推荐使用第二种方式。

### 测试

当我们配置好 CORS 后，可以在浏览器中测试一下规则是否生效。

我们先用 `http://localhost:8080` 在 Chrome 浏览器中打开首页，然后打开 Chrome 的开发者工具，切换到 Console，输入一个 JavaScript 语句来跨域访问 API：

```
$.getJSON("http://local.liaoxuefeng.com:8080/api/users", (data) => console.log(JSON.stringify(data)));
```

上述源站的域是 `http://localhost:8080`，跨域访问的是 `http://local.liaoxuefeng.com:8080`，因为配置的 CORS 不允许 `localhost` 访问，所以不出意外地得到一个错误：

![cors-deny](./assets/l-20231221154348695.png)

浏览题打印了错误原因就是 `been blocked by CORS policy`。

我们再用 `http://local.liaoxuefeng.com:8080` 在 Chrome 浏览器中打开首页，在 Console 中执行 JavaScript 访问 `localhost`：

```
$.getJSON("http://localhost:8080/api/users", (data) => console.log(JSON.stringify(data)));
```

因为 CORS 规则允许来自 `http://local.liaoxuefeng.com:8080` 的访问，因此访问成功，打印出 API 的返回值：

![cors-ok](./assets/l-20231221154348764.png)

### 练习

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[使用 CORS 控制跨域](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/50. 处理 CORS.1282384360112162/spring-web-mvc-cors.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

CORS 可以控制指定域的页面 JavaScript 能否访问 API。



# 国际化

Last updated: 2023/8/25 07:53 / Reads: 255111

------

在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是 internationalization，缩写为 i18n（因为首字母 i 和末字母 n 中间有 18 个字母）。

还有针对特定地区的本地化功能，英文是 localization，缩写为 L10n，本地化是指根据地区调整类似姓名、日期的显示等。

也有把上面两者合称为全球化，英文是 globalization，缩写为 g11n。

在 Java 中，支持多语言和本地化是通过 `MessageFormat` 配合 `Locale` 实现的：

```
// MessageFormat
import java.text.MessageFormat;
import java.util.Locale;

public class Time {
    public static void main(String[] args) {
        double price = 123.5;
        int number = 10;
        Object[] arguments = { price, number};
        MessageFormat mfUS = new MessageFormat("Pay {0,number,currency} for {1} books.", Locale.US);
        System.out.println(mfUS.format(arguments));
        MessageFormat mfZH = new MessageFormat("{1} 本书一共 {0,number,currency}。", Locale.CHINA);
        System.out.println(mfZH.format(arguments));
    }
}
```



对于 Web 应用程序，要实现国际化功能，主要是渲染 View 的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。

我们来看看在 Spring MVC 应用程序中如何实现国际化。

### 获取 Locale

实现国际化的第一步是获取到用户的 `Locale`。在 Web 应用程序中，HTTP 规范规定了浏览器会在请求中携带 `Accept-Language` 头，用来指示用户浏览器设定的语言顺序，如：

```
Accept-Language: zh-CN,zh;q=0.8,en;q=0.2
```

上述 HTTP 请求头表示优先选择简体中文，其次选择中文，最后选择英文。`q` 表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为 Java 的 `Locale`，即获得了用户的 `Locale`。大多数框架通常只返回权重最高的 `Locale`。

Spring MVC 通过 `LocaleResolver` 来自动从 `HttpServletRequest` 中获取 `Locale`。有多种 `LocaleResolver` 的实现类，其中最常用的是 `CookieLocaleResolver`：

```
@Primary
@Bean
LocaleResolver createLocaleResolver() {
    var clr = new CookieLocaleResolver();
    clr.setDefaultLocale(Locale.ENGLISH);
    clr.setDefaultTimeZone(TimeZone.getDefault());
    return clr;
}
```

`CookieLocaleResolver` 从 `HttpServletRequest` 中获取 `Locale` 时，首先根据一个特定的 Cookie 判断是否指定了 `Locale`，如果没有，就从 HTTP 头获取，如果还没有，就返回默认的 `Locale`。

当用户第一次访问网站时，`CookieLocaleResolver` 只能从 HTTP 头获取 `Locale`，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，`CookieLocaleResolver` 就会把用户选择的语言存放到 Cookie 中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。

### 提取资源文件

第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为 `messages`，那么资源文件必须按如下方式命名并放入 classpath 中：

- 默认语言，文件名必须为 `messages.properties`；
- 简体中文，Locale 是 `zh_CN`，文件名必须为 `messages_zh_CN.properties`；
- 日文，Locale 是 `ja_JP`，文件名必须为 `messages_ja_JP.properties`；
- 其它更多语言……

每个资源文件都有相同的 key，例如，默认语言是英文，文件 `messages.properties` 内容如下：

```
language.select=Language
home=Home
signin=Sign In
copyright=Copyright©{0,number,#}
```

文件 `messages_zh_CN.properties` 内容如下：

```
language.select = 语言
home = 首页
signin = 登录
copyright = 版权所有 ©{0,number,#}
```

### 创建 MessageSource

第三步是创建一个 Spring 提供的 `MessageSource` 实例，它自动读取所有的 `.properties` 文件，并提供一个统一接口来实现 “翻译”：

```
// code, arguments, locale:
String text = messageSource.getMessage("signin", null, locale);
```

其中，`signin` 是我们在 `.properties` 文件中定义的 key，第二个参数是 `Object[]` 数组作为格式化时传入的参数，最后一个参数就是获取的用户 `Locale` 实例。

创建 `MessageSource` 如下：

```
@Bean("i18n")
MessageSource createMessageSource() {
    var messageSource = new ResourceBundleMessageSource();
    // 指定文件是 UTF-8 编码:
    messageSource.setDefaultEncoding("UTF-8");
    // 指定主文件名:
    messageSource.setBasename("messages");
    return messageSource;
}
```

注意到 `ResourceBundleMessageSource` 会自动根据主文件名自动把所有相关语言的资源文件都读进来。

再注意到 Spring 容器会创建不只一个 `MessageSource` 实例，我们自己创建的这个 `MessageSource` 是专门给页面国际化使用的，因此命名为 `i18n`，不会与其它 `MessageSource` 实例冲突。

### 实现多语言

要在 View 中使用 `MessageSource` 加上 `Locale` 输出多语言，我们通过编写一个 `MvcInterceptor`，把相关资源注入到 `ModelAndView` 中：

```
@Component
public class MvcInterceptor implements HandlerInterceptor {
    @Autowired
    LocaleResolver localeResolver;

    // 注意注入的 MessageSource 名称是 i18n:
    @Autowired
    @Qualifier("i18n")
    MessageSource messageSource;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        if (modelAndView != null // 返回了 ModelAndView
            && modelAndView.getViewName() != null // 设置了 View
            && !modelAndView.getViewName().startsWith("redirect:") // 不是重定向
        ) {
            // 解析用户的 Locale:
            Locale locale = localeResolver.resolveLocale(request);
            // 放入 Model:
            modelAndView.addObject("__messageSource__", messageSource);
            modelAndView.addObject("__locale__", locale);
        }
    }
}
```

不要忘了在 `WebMvcConfigurer` 中注册 `MvcInterceptor`。现在，就可以在 View 中调用 `MessageSource.getMessage()` 方法来实现多语言：

```
<a href="/signin">{{ __messageSource__.getMessage('signin', null, __locale__) }}</a>
```

上述这种写法虽然可行，但格式太复杂了。使用 View 时，要根据每个特定的 View 引擎定制国际化函数。在 Pebble 中，我们可以封装一个国际化函数，名称就是下划线 `_`，改造一下创建 `ViewResolver` 的代码：

```
@Bean
ViewResolver createViewResolver(@Autowired ServletContext servletContext, @Autowired @Qualifier("i18n") MessageSource messageSource) {
    var engine = new PebbleEngine.Builder()
            .autoEscaping(true)
            .cacheActive(false)
            .loader(new Servlet5Loader(servletContext))
            // 添加扩展:
            .extension(createExtension(messageSource))
            .build();
    var viewResolver = new PebbleViewResolver();
    viewResolver.setPrefix("/WEB-INF/templates/");
    viewResolver.setSuffix("");
    viewResolver.setPebbleEngine(engine);
    return viewResolver;
}

private Extension createExtension(MessageSource messageSource) {
    return new AbstractExtension() {
        @Override
        public Map<String, Function> getFunctions() {
            return Map.of("_", new Function() {
                public Object execute(Map<String, Object> args, PebbleTemplate self, EvaluationContext context, int lineNumber) {
                    String key = (String) args.get("0");
                    List<Object> arguments = this.extractArguments(args);
                    Locale locale = (Locale) context.getVariable("__locale__");
                    return messageSource.getMessage(key, arguments.toArray(), "???" + key + "???", locale);
                }
                private List<Object> extractArguments(Map<String, Object> args) {
                    int i = 1;
                    List<Object> arguments = new ArrayList<>();
                    while (args.containsKey(String.valueOf(i))) {
                        Object param = args.get(String.valueOf(i));
                        arguments.add(param);
                        i++;
                    }
                    return arguments;
                }
                public List<String> getArgumentNames() {
                    return null;
                }
            });
        }
    };
}
```

这样，我们可以把多语言页面改写为：

```
<a href="/signin">{{ _('signin') }}</a>
```

如果是带参数的多语言，需要把参数传进去：

```
<h5>{{ _('copyright', 2020) }}</h5>
```

使用其它 View 引擎时，也应当根据引擎接口实现更方便的语法。

### 切换 Locale

最后，我们需要允许用户手动切换 `Locale`，编写一个 `LocaleController` 来实现该功能：

```
@Controller
public class LocaleController {
    final Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    LocaleResolver localeResolver;

    @GetMapping("/locale/{lo}")
    public String setLocale(@PathVariable("lo") String lo, HttpServletRequest request, HttpServletResponse response) {
        // 根据传入的 lo 创建 Locale 实例:
        Locale locale = null;
        int pos = lo.indexOf('_');
        if (pos> 0) {
            String lang = lo.substring(0, pos);
            String country = lo.substring(pos + 1);
            locale = new Locale(lang, country);
        } else {
            locale = new Locale(lo);
        }
        // 设定此 Locale:
        localeResolver.setLocale(request, response, locale);
        logger.info("locale is set to {}.", locale);
        // 刷新页面:
        String referer = request.getHeader("Referer");
        return "redirect:" + (referer == null ? "/" : referer);
    }
}
```

在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：

![i18n-en](./assets/l-20231221154408761.png)

切换到中文：

![i18n-zh-cn](./assets/l-20231221154408728.png)

### 练习

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[在 MVC 程序中实现国际化](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/60. 国际化. 1282384236380194/spring-web-mvc-i18n.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

多语言支持需要从 HTTP 请求中解析用户的 Locale，然后针对不同 Locale 显示不同的语言；

Spring MVC 应用程序通过 `MessageSource` 和 `LocaleResolver`，配合 View 实现国际化。



# 异步处理

Last updated: 2022/11/16 23:09 / Reads: 170134

------

在 Servlet 模型中，每个请求都是由某个线程处理，然后，将响应写入 IO 流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。

实现 Servlet 容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了 Servlet 线程模型。在实际产品中，例如 Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。

这种线程模型非常重要，因为 Spring 的 JDBC 事务是基于 `ThreadLocal` 实现的，如果在处理过程中，一会由线程 A 处理，一会又由线程 B 处理，那事务就全乱套了。此外，很多安全认证，也是基于 `ThreadLocal` 实现的，可以保证在处理请求的过程中，各个线程互不影响。

但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet 从 3.0 规范开始添加了异步支持，允许对一个请求进行异步处理。

我们先来看看在 Spring MVC 中如何实现对请求进行异步处理的逻辑。首先建立一个 Web 工程，然后编辑 `web.xml` 文件如下：

```
<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
        </init-param>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.itranswarp.learnjava.AppConfig</param-value>
        </init-param>
        <load-on-startup>0</load-on-startup>
        <async-supported>true</async-supported>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>
```

和前面普通的 MVC 程序相比，这个 `web.xml` 主要对 `DispatcherServlet` 的配置多了一个 `<async-supported>`，默认值是 `false`，必须明确写成 `true`，这样 Servlet 容器才会支持 async 处理。

下一步就是在 Controller 中编写 async 处理逻辑。我们以 `ApiController` 为例，演示如何异步处理请求。

第一种 async 处理方式是返回一个 `Callable`，Spring MVC 自动把返回的 `Callable` 放入线程池执行，等待结果返回后再写入响应：

```
@GetMapping("/users")
public Callable<List<User>> users() {
    return () -> {
        // 模拟 3 秒耗时:
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
        }
        return userService.getUsers();
    };
}
```

第二种 async 处理方式是返回一个 `DeferredResult` 对象，然后在另一个线程中，设置此对象的值并写入响应：

```
@GetMapping("/users/{id}")
public DeferredResult<User> user(@PathVariable("id") long id) {
    DeferredResult<User> result = new DeferredResult<>(3000L); // 3 秒超时
    new Thread(() -> {
        // 等待 1 秒:
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        try {
            User user = userService.getUserById(id);
            // 设置正常结果并由 Spring MVC 写入 Response:
            result.setResult(user);
        } catch (Exception e) {
            // 设置错误结果并由 Spring MVC 写入 Response:
            result.setErrorResult(Map.of("error", e.getClass().getSimpleName(), "message", e.getMessage()));
        }
    }).start();
    return result;
}
```

使用 `DeferredResult` 时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用 `setResult()` 写入结果，也可以调用 `setErrorResult()` 写入一个错误结果。

运行程序，当我们访问 `http://localhost:8080/api/users/1` 时，假定用户存在，则浏览器在 1 秒后返回结果：

![deferred-result-ok](./assets/l-20231221154445746.png)

访问一个不存在的 User ID，则等待 1 秒后返回错误结果：

![deferred-result-error](./assets/l-20231221154445845.png)

### 使用 Filter

当我们使用 async 模式处理请求时，原有的 Filter 也可以工作，但我们必须在 `web.xml` 中添加 `<async-supported>` 并设置为 `true`。我们用两个 Filter：SyncFilter 和 AsyncFilter 分别测试：

```
<web-app ...>
    ...
    <filter>
        <filter-name>sync-filter</filter-name>
        <filter-class>com.itranswarp.learnjava.web.SyncFilter</filter-class>
    </filter>

    <filter>
        <filter-name>async-filter</filter-name>
        <filter-class>com.itranswarp.learnjava.web.AsyncFilter</filter-class>
        <async-supported>true</async-supported>
    </filter>

    <filter-mapping>
        <filter-name>sync-filter</filter-name>
        <url-pattern>/api/version</url-pattern>
    </filter-mapping>

    <filter-mapping>
        <filter-name>async-filter</filter-name>
        <url-pattern>/api/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

一个声明为支持 `<async-supported>` 的 Filter 既可以过滤 async 处理请求，也可以过滤正常的同步处理请求，而未声明 `<async-supported>` 的 Filter 无法支持 async 请求，如果一个普通的 Filter 遇到 async 请求时，会直接报错，因此，务必注意普通 Filter 的 `<url-pattern>` 不要匹配 async 请求路径。

在 `logback.xml` 配置文件中，我们把输出格式加上 `[%thread]`，可以输出当前线程的名称：

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</Pattern>
        </layout>
    </appender>
    ...
</configuration>
```

对于同步请求，例如 `/api/version`，我们可以看到如下输出：

```
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.
2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.
```

可见，每个 Filter 和 `ApiController` 都是由同一个线程执行。

对于异步请求，例如 `/api/users`，我们可以看到如下输出：

```
2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...
2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...
2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.
2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...
```

可见，`AsyncFilter` 和 `ApiController` 是由同一个线程执行的，但是，返回响应的是另一个线程。

对 `DeferredResult` 测试，可以看到如下输出：

```
2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...
2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.
2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.
```

同样，返回响应的是另一个线程。

在实际使用时，经常用到的就是 `DeferredResult`，因为返回 `DeferredResult` 时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。

使用 async 异步处理响应时，要时刻牢记，在另一个异步线程中的事务和 Controller 方法中执行的事务不是同一个事务，在 Controller 中绑定的 `ThreadLocal` 信息也无法在异步线程中获取。

此外，Servlet 3.0 规范添加的异步支持是针对同步模型打了一个 “补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生” 异步。Java 标准库提供了封装操作系统的异步 IO 包 `java.nio`，是真正的多路复用 IO 模型，可以用少量线程支持大量并发。使用 NIO 编程复杂度比同步 IO 高很多，因此我们很少直接使用 NIO。相反，大部分需要高性能异步 IO 的应用程序会选择 [Netty](https://netty.io/) 这样的框架，它基于 NIO 提供了更易于使用的 API，方便开发异步应用程序。

### 练习

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[使用 Spring MVC 实现异步处理请求](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/70. 异步处理. 1282384506912802/spring-web-mvc-async.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

在 Spring MVC 中异步处理请求需要正确配置 `web.xml`，并返回 `Callable` 或 `DeferredResult` 对象。



# 使用 WebSocket

Last updated: 2022/11/16 23:17 / Reads: 381530

------

WebSocket 是一种基于 HTTP 的长链接技术。传统的 HTTP 协议是一种请求 - 响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于 HTTP 协议实现这类需求，只能依靠浏览器的 JavaScript 定时轮询，效率很低且实时性不高。

因为 HTTP 本身是基于 TCP 连接的，所以，WebSocket 在 HTTP 协议的基础上做了一个简单的升级，即建立 TCP 连接后，浏览器发送请求时，附带几个头：

```
GET /chat HTTP/1.1
Host: www.example.com
Upgrade: websocket
Connection: Upgrade
```

就表示客户端希望升级连接，变成长连接的 WebSocket，服务器返回升级成功的响应：

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
```

收到成功响应后表示 WebSocket“握手” 成功，这样，代表 WebSocket 的这个 TCP 连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于 JSON 的文本消息。

现代浏览器都已经支持 WebSocket 协议，服务器则需要底层框架支持。Java 的 Servlet 规范从 3.1 开始支持 WebSocket，所以，必须选择支持 Servlet 3.1 或更高规范的 Servlet 容器，才能支持 WebSocket。最新版本的 Tomcat、Jetty 等开源服务器均支持 WebSocket。

我们以实际代码演示如何在 Spring MVC 中实现对 WebSocket 的支持。首先，我们需要在 `pom.xml` 中加入以下依赖：

- org.apache.tomcat.embed:tomcat-embed-websocket:10.1.1
- org.springframework:spring-websocket:6.0.0

第一项是嵌入式 Tomcat 支持 WebSocket 的组件，第二项是 Spring 封装的支持 WebSocket 的接口。

接下来，我们需要在 AppConfig 中加入 Spring Web 对 WebSocket 的配置，此处我们需要创建一个 `WebSocketConfigurer` 实例：

```
@Bean
WebSocketConfigurer createWebSocketConfigurer(
        @Autowired ChatHandler chatHandler,
        @Autowired ChatHandshakeInterceptor chatInterceptor)
{
    return new WebSocketConfigurer() {
        public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
            // 把 URL 与指定的 WebSocketHandler 关联，可关联多个:
            registry.addHandler(chatHandler, "/chat").addInterceptors(chatInterceptor);
        }
    };
}
```

此实例在内部通过 `WebSocketHandlerRegistry` 注册能处理 WebSocket 的 `WebSocketHandler`，以及可选的 WebSocket 拦截器 `HandshakeInterceptor`。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到 WebSocket 的 URL 是 `/chat`。

### 处理 WebSocket 连接

和处理普通 HTTP 请求不同，没法用一个方法处理一个 URL。Spring 提供了 `TextWebSocketHandler` 和 `BinaryWebSocketHandler` 分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，`ChatHandler` 需要继承自 `TextWebSocketHandler`：

```
@Component
public class ChatHandler extends TextWebSocketHandler {
    ...
}
```

当浏览器请求一个 WebSocket 连接后，如果成功建立连接，Spring 会自动调用 `afterConnectionEstablished()` 方法，任何原因导致 WebSocket 连接中断时，Spring 会自动调用 `afterConnectionClosed` 方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：

```
@Component
public class ChatHandler extends TextWebSocketHandler {
    // 保存所有 Client 的 WebSocket 会话实例:
    private Map<String, WebSocketSession> clients = new ConcurrentHashMap<>();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        // 新会话根据 ID 放入 Map:
        clients.put(session.getId(), session);
        session.getAttributes().put("name", "Guest1");
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        clients.remove(session.getId());
    }
}
```

每个 WebSocket 会话以 `WebSocketSession` 表示，且已分配唯一 ID。和 WebSocket 相关的数据，例如用户名称等，均可放入关联的 `getAttributes()` 中。

用实例变量 `clients` 持有当前所有的 `WebSocketSession` 是为了广播，即向所有用户推送同一消息时，可以这么写：

```
String json = ...
TextMessage message = new TextMessage(json);
for (String id : clients.keySet()) {
    WebSocketSession session = clients.get(id);
    session.sendMessage(message);
}
```

我们发送的消息是序列化后的 JSON，可以用 `ChatMessage` 表示：

```
public class ChatMessage {
	public long timestamp;
	public String name;
    public String text;
}
```

每收到一个用户的消息后，我们就需要广播给所有用户：

```
@Component
public class ChatHandler extends TextWebSocketHandler {
    ...
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String s = message.getPayload();
        String r = ... // 根据输入消息构造待发送消息
        broadcastMessage(r); // 推送给所有用户
    }
}
```

如果要推送给指定的几个用户，那就需要在 `clients` 中根据条件查找出某些 `WebSocketSession`，然后发送消息。

注意到我们在注册 WebSocket 时还传入了一个 `ChatHandshakeInterceptor`，这个类实际上可以从 `HttpSessionHandshakeInterceptor` 继承，它的主要作用是在 WebSocket 建立连接后，把 HttpSession 的一些属性复制到 WebSocketSession，例如，用户的登录信息等：

```
@Component
public class ChatHandshakeInterceptor extends HttpSessionHandshakeInterceptor {
    public ChatHandshakeInterceptor() {
        // 指定从 HttpSession 复制属性到 WebSocketSession:
        super(List.of(UserController.KEY_USER));
    }
}
```

这样，在 `ChatHandler` 中，可以从 `WebSocketSession.getAttributes()` 中获取到复制过来的属性。

### 客户端开发

在完成了服务器端的开发后，我们还需要在页面编写一点 JavaScript 逻辑：

```
// 创建 WebSocket 连接:
var ws = new WebSocket('ws://' + location.host + '/chat');
// 连接成功时:
ws.addEventListener('open', function (event) {
    console.log('websocket connected.');
});
// 收到消息时:
ws.addEventListener('message', function (event) {
    console.log('message:' + event.data);
    var msgs = JSON.parse(event.data);
    // TODO:
});
// 连接关闭时:
ws.addEventListener('close', function () {
    console.log('websocket closed.');
});
// 绑定到全局变量:
window.chatWs = ws;
```

用户可以在连接成功后任何时候给服务器发送消息：

```
var inputText = 'Hello, WebSocket.';
window.chatWs.send(JSON.stringify({text: inputText}));
```

最后，连调浏览器和服务器端，如果一切无误，可以开多个不同的浏览器测试 WebSocket 的推送和广播：

![chat](./assets/l-20231221154501285.png)

和上一节我们介绍的异步处理类似，Servlet 的线程模型并不适合大规模的长链接。基于 NIO 的 Netty 等框架更适合处理 WebSocket 长链接，我们将在后面介绍。

### 练习

从 [![img](data:image/png;base64,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)](https://gitee.com/) 下载练习：[使用 WebSocket 编写一个聊天室](https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java 教程 / 210.Spring 开发. 1266263217140032/40. 开发 Web 应用. 1282383877767201/80. 使用 WebSocket.1282384966189089/spring-web-mvc-websocket.zip?utm_source=blog_lxf) （推荐使用 [IDE 练习插件](https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664) 快速下载）

### 小结

在 Servlet 中使用 WebSocket 需要 3.1 及以上版本；

通过 `spring-websocket` 可以简化 WebSocket 的开发。
