## 排序算法

***排序*** ：

假设含有 n 个记录的序列为 $\{R_1,R_2,...,R_n\}$，其相应的关键字序列为 $\{K_1,K_2,...,K_n\}$。  

将这些记录重新排序为 $\{R_{i1},R_{i2},...,R_{in}\}$，使得相应的关键字值满足条 $K_{i1}<=K_{i2}<=...<=K_{in}$，这样的一种操作称为排序。

?> 通常来说，排序的目的是快速查找。


### 衡量排序算法的优劣：

1. **时间复杂度**：分析关键字的比较次数和记录的移动次数
2. **空间复杂度**：分析排序算法中需要多少辅助内存
3. **稳定性**：若两个记录 A 和 B 的关键字值相等，但排序后 A 、 B 的先后次序保持不变，则称这种排序算法是稳定的。

### 排序算法分类：

- *内部排序* ：
    整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
- *外部排序* ：
    参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，
    必须借助于外部存储器（如磁盘）。外部排序最常见的是 *多路归并排序* 。
    可以认为外部排序是由多次内部排序组成。

### 十大内部排序算法

- 选择排序
   - 直接选择排序、堆排序
- 交换排序
   - 冒泡排序、快速排序
- 插入排序
   - 直接插入排序、折半插入排序、Shell 排序
- 归并排序
- 桶式排序
- 基数排序


## 1 （简单）选择排序

![(简单)选择排序.gif](https://gxmnzl.cn//img/Sort1.gif "-gifcontrol-mode=click;")


---

## 2 （直接）插入排序

![(直接)插入排序.gif](https://gxmnzl.cn//img/Sort2.gif "-gifcontrol-mode=click;")


---

## 3 堆排序

![堆排序.gif](https://gxmnzl.cn//img/Sort3.gif "-gifcontrol-mode=click;")


---

## 4 归并排序

![归并排序.gif](https://gxmnzl.cn//img/Sort4.gif "-gifcontrol-mode=click;")


---

## 5 基数排序

![基数排序.gif](https://gxmnzl.cn//img/Sort5.gif "-gifcontrol-mode=click;")


---

## 6 计数排序

![计数排序.gif](https://gxmnzl.cn//img/Sort6.gif "-gifcontrol-mode=click;")


---

## 7 快速排序

![快速排序.gif](https://gxmnzl.cn//img/Sort7.gif "-gifcontrol-mode=click;")

### 介绍 

- 快速排序通常明显比同为 $O_{nlog(n)}$ 的其他算法更快，因此常被采用，而且快排采用了分治法的思想，
所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。 
- 快速排序（Quick Sort）由图灵奖获得者 Tony Hoare 发明，被列为 20 世纪十大算法之一，
是迄今为止所有内排序算法中速度最快的一种。
- 冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为 $O_{nlog(n)}$。

### 排序思想
1. 从数列中挑出一个元素，称为"基准"(pivot)。
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。 
3. 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。
4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。

---
## 8 冒泡排序

![冒泡排序.gif](https://gxmnzl.cn//img/Sort8.gif "-gifcontrol-mode=click;")

### 介绍
冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 

### 排序思想
1. 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 
3. 针对所有的元素重复以上的步骤，除了最后一个。 
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。

#### 具体过程：

若序列中有 n 个元素，通常进行 n-1 趟。  
- 第 1 趟，针对第 `R[1]` 至 `R[n]` 个元素进行。  
- 第 2 趟，针对第 `R[1]` 至 `R[n－1]` 个元素进行。  
- …… 第 n-1 趟，针对第 `R[1]` 至 `R[2]` 个元素进行。


---

## 9 桶排序

![桶排序.png](https://gxmnzl.cn//img/Sort9.png)


---

## 10 希尔排序

![希尔排序.gif](https://gxmnzl.cn//img/Sort10.gif "-gifcontrol-mode=click;")


---

## 算法的 5 大特征

|                                 |                                                                                      |
| :-----------------------------: | ------------------------------------------------------------------------------------ |
|          *输入(Input)*          | 有 0 个或多个输入数据，这些输入必须有清楚的描述和定义                                |
|         *输出(Output)*          | 至少有 1 个或多个输出结果，不可以没有输出结果                                        |
|  *有穷性(有限性，Finiteness)*   | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 |
| *确定性(明确性，Definiteness)*  | 算法中的每一步都有确定的含义，不会出现二义性                                         |
| *可行性(有效性，Effectiveness)* | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案                           |


---

## @各种内部排序方法性能比较

![image.png](https://gxmnzl.cn//img/SE0305.png)


1. **从平均时间而言**：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。 
2. ​**从算法简单性看**：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。 
3. ​**从稳定性看**：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序。
4. **从待排序的记录数n的大小看**，n较小时，宜采用简单排序；而n较大时宜采用改进排序。



---

## @排序算法的选择 
1. 若 n 较小(如 n ≤ 50 )，可采用**直接插入**或**直接选择排序**。当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。 
2. 若文件初始状态基本有序(指正序)，则应选用**直接插入**、**冒泡**或随机的**快速排序**为宜； 
3. 若 n 较大，则应采用时间复杂度为 O<sub>(nlgn)</sub> 的排序方法：**快速排序**、**堆排序**或**归并排序**。















