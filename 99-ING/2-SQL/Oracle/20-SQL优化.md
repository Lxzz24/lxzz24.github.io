# **20 - SQL优化**
[<<返回首页](database/Oracle.md)

1. `SQL` 语句尽量用大写的
2. 使用表的别名
   当在 `SQL` 语句中连接多个表时, 尽量使用表的别名并把别名前缀于每个列上，可以减少解析的时间并减少那些由列歧义引起的语法错误。
3. 选择最有效率的表名顺序(只在基于规则的优化器中有效)
4. `Where` 子句后面的条件过滤有讲究
   `ORACLE`对`where`子句后面的条件过滤是自下向上，从右向左扫描的，所以和`From`子句一样一样的，把过滤条件排个序，按过滤数据的大小，自然就是可以过滤掉最大数量记录的条件必须写在`WHERE`子句的末尾最下面，最右边，依次类推
5. 在 `select` 的时候少用 `*` 
   `ORACLE` 的查询器会把 `*` 转换为表的全部列名，会浪费时间。
6. 使用`rowid`
   常用于分页，删除查询重复记录
7. 减少对数据库表的查询
8. 使用 `DECODE` 函数来减少处理时间
9. 整合简单,无关联的数据库访问
10. 删除重复记录
    最高效的删除重复记录方法 (因为使用了 `ROWID` )例子：
    `DELETE  FROM  EMP E  WHERE  E.ROWID > (SELECT MIN(X.ROWID)`
    `FROM  EMP X  WHERE  X.EMP_NO = E.EMP_NO);`
11. 用 `TRUNCATE` 替代 `DELETE`
12. 存储过程中多用 `commit` (谨慎使用)
    程序的性能得到提高,需求也会因为 `COMMIT` 所释放的资源而减少 `COMMIT` 所释放的资源:
    a. 回滚段上用于恢复数据的信息.
    b. 被程序语句获得的锁
    c. `redo log buffer` 中的空间
    d. `ORACLE` 为管理上述3种资源中的内部花费
13. 不要用 `in`，`not in`，用 `exists`，`not exists` 来代替
14. 用 `Where` 子句替换 `HAVING` 子句
15. 减少对表的查询
    在含有子查询的 `SQL` 语句中,要特别注意减少对表的查询. 
16. 通过内部函数提高 `SQL` 效率
17. 识别’低效执行’的 `SQL` 语句
18. 用索引提高效率
19. 用 `EXISTS` 替换 `DISTINCT`
20. 在 `Java` 代码中尽量少用连接符 `＋` 连接字符串！
21. 通常避免在索引列上使用 `NOT`
22. 避免在索引列上使用计算
23. 用 `>=` 替代 `>` 
24. 用 `UNION` 替换 `OR` (适用于索引列) 
25. 避免在索引列上使用 `IS NULL` 和 `IS NOT NULL` 
26. 总是使用索引的第一个列
27. 用 `UNION-ALL` 替换 `UNION` ( 如果有可能的话)
28. 用 `WHERE` 替代 `ORDER BY`
29. 避免改变索引列的类型
30. 需要当心的 `WHERE` 子句
31. 使用索引需要注意的两点
    a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高。
    b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要快几倍乃至几千倍! 
32. 避免使用耗费资源的操作
    带有 `DISTINCT`, `UNION`, `MINUS`, `INTERSECT`, `ORDER BY` 的 `SQL` 语句会启动 `SQL` 引擎
33. 优化 `GROUP BY`
