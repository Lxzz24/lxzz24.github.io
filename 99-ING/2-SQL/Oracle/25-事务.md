# **25 - 事务**
[<<返回首页](database/Oracle.md)

> 在数据库中事务是工作的逻辑单元，一个事务是由一个或多个完成一组的相关行为的SQL语句组成，通过事务机制确保这一组SQL语句所作的操作要么都成功执行，完成整个工作单元操作，要么一个也不执行。


## 事务具有原子性，一致性，隔离性，持久性
- **原子性**：事务必须是一个自动工作的单元，要么全部执行，要么全部不执行。
- **一致性**：事务结束的时候，所有的内部数据都是正确的。
- **隔离性**：并发多个事务时，各个事务不干涉内部数据，处理的都是另外一个事务处理之前或之后的数据。
- **持久性**：事务提交之后，数据是永久性的，不可再回滚。


## 在多用户都用事务同时访问同一个数据资源的情况下，就会造成以下几种数据错误：
- **更新丢失**：  
  多个用户同时对一个数据资源进行更新，必定会产生被覆盖的数据，造成数据读写异常。

- **不可重复读**：  
  如果一个用户在一个事务中多次读取一条数据，而另外一个用户则同时更新啦这条数据，造成第一个用户多次读取数据不一致。
- **脏读**：  
  第一个事务读取第二个事务正在更新的数据表，如果第二个事务还没有更新完成，那么第一个事务读取的数据将是一半为更新过的，一半还没更新过的数据，这样的数据毫无意义。
- **幻读**：  
  第一个事务读取一个结果集后，第二个事务，对这个结果集经行增删操作，然而第一个事务中再次对这个结果集进行查询时，数据发现丢失或新增。

## 锁定
> 锁定，就是为解决这些问题所生的，他的存在使得一个事务对他自己的数据块进行操作的时候，而另外一个事务则不能插足这些数据块。这就是所谓的锁定。

锁定从数据库系统的角度大致可以分为6种：  
### **共享锁（S）**：
还可以叫他读锁。可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁的时候，所有的事务都不能对这个资源进行修改，直到数据读取完成，共享锁释放。

### **排它锁（X）**：
还可以叫他独占锁、写锁。就是如果你对数据资源进行增删改操作时，不允许其它任何事务操作这块资源，直到排它锁被释放，防止同时对同一资源进行多重操作。

### **更新锁（U）**：
防止出现死锁的锁模式，两个事务对一个数据资源进行先读取在修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁则可以避免死锁的出现。资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排他锁，否则变为共享锁。

### **意向锁**：
SQL Server需要在层次结构中的底层资源上（如行，列）获取共享锁，排它锁，更新锁。例如表级放置了意向共享锁，就表示事务要对表的页或行上使用共享锁。在表的某一行上上放置意向锁，可以防止其它事务获取其它不兼容的的锁。意向锁可以提高性能，因为数据引擎不需要检测资源的每一列每一行，就能判断是否可以获取到该资源的兼容锁。意向锁包括三种类型：意向共享锁（IS），意向排他锁（IX），意向排他共享锁（SIX）。

### **架构锁**：
防止修改表结构时，并发访问的锁。

### **大容量更新锁**：
允许多个线程将大容量数据并发的插入到同一个表中，在加载的同时，不允许其它进程访问该表。
这些锁之间的相互兼容性，也就是，是否可以同时存在。  
​
## 兼容性：
| - | S | X | RS | RX | SRX | N/A |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| S   | √ | × | √ | × | × | √ |
| X   | × | × | × | × | × | √ |
| RS  | √ | × | √ | √ | √ | √ |
| RX  | × | × | √ | √ | × | √ |
| SRX | × | × | √ | × | × | √ |
| N/A | √ | √ | √ | √ | √ | √ |